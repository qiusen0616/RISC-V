\chapter{RVWMO内存一致性模型（2.0版本）}
% \chapter{RVWMO Memory Consistency Model, Version 2.0}
\label{ch:memorymodel}

这章定义了RISC-V内存一致性模型。内存一致性模型是一组规则的集合，它指定了可以被内存的加载所返回的值。
RISC-V使用一个叫做“RVWMO”（RISC-V弱内存次序）的内存模型，它被设计来为架构提供构建高性能可扩展设计的灵活性，
并同时支持易处理的编程模型。
% This chapter defines the RISC-V memory consistency model.
% A memory consistency model is a set of rules specifying the values that can be returned by loads of memory.
% RISC-V uses a memory model called ``RVWMO'' (RISC-V Weak Memory Ordering) which is designed to provide flexibility for architects to build high-performance scalable designs while simultaneously supporting a tractable programming model.

在RVWMO下，从同一硬件线程的其它内存指令的视角来看，运行在单一硬件线程的代码看似有序地执行，但是从另一个硬件线程的内存指令，可能观察到第一个硬件线程的内存指令正在以一种不同的次序被执行。
因此，多线程代码可能需要显式的同步，来保证来自不同硬件线程的内存指令之间的次序。基础RISC-V ISA出于这个目的，提供了一个FENCE指令，它描述在~\ref{sec:fence}节中，同时原子扩展“A”额外定义了“加载-保留”/“存储-条件”和原子性“读-修改-写”指令。
% Under RVWMO, code running on a single hart appears to execute in order from the perspective of other memory instructions in the same hart, but memory instructions from another hart may observe the memory instructions from the first hart being executed in a different order.
% Therefore, multithreaded code may require explicit synchronization to guarantee ordering between memory instructions from different harts.
% The base RISC-V ISA provides a FENCE instruction for this purpose, described in Section~\ref{sec:fence}, while the atomics extension ``A'' additionally defines load-reserved/store-conditional and atomic read-modify-write instructions.

用于未对齐原子性的标准ISA扩展“Zam”（第~\ref{sec:zam}章）和用于全存储排序的标准ISA扩展“Ztso”（第~\ref{sec:ztso}章）为RVWMO增加了特定于那些扩展的额外的规则。
% The standard ISA extension for misaligned atomics ``Zam'' (Chapter~\ref{sec:zam}) and the standard ISA extension for total store ordering ``Ztso'' (Chapter~\ref{sec:ztso}) augment RVWMO with additional rules specific to those extensions.

这个规范的附录提供了公理化的和操作规范化的内存一致性以及补充说明材料。
% The appendices to this specification provide both axiomatic and operational formalizations of the memory consistency model as well as additional explanatory material.

\begin{commentary}
  这章定义了用于规则的主内存操作的内存模型。使用I/O内存、指令获取、FENCE.I、页表游走和SFENCE.VMA的内存模型交互还没有被规范化。上述中的一些或全部可能在这个规范未来的修订中被规范化。RV128基础ISA和未来的ISA扩展（例如“V”向量扩展和“J”JIT扩展）也将需要被并入未来的修订中。
  % This chapter defines the memory model for regular main memory operations.  The interaction of the memory model with I/O memory, instruction fetches, FENCE.I, page table walks, and SFENCE.VMA is not (yet) formalized.  Some or all of the above may be formalized in a future revision of this specification.  The RV128 base ISA and future ISA extensions such as the ``V'' vector and ``J'' JIT extensions will need to be incorporated into a future revision as well.

  支持不同宽度同时进行重叠的内存访问的内存一致性模型仍然是学术研究的一个积极区域，并且还没有被完全理解。关于不同尺寸的内存访问如何在RVWMO下交互的细节是我们当前能做到的最好的，但是当新问题被揭露后，它们将不得不再修订。
  % Memory consistency models supporting overlapping memory accesses of different widths simultaneously remain an active area of academic research and are not yet fully understood.  The specifics of how memory accesses of different sizes interact under RVWMO are specified to the best of our current abilities, but they are subject to revision should new issues be uncovered.
\end{commentary}

\section{RVWMO内存模型的定义}
% \section{Definition of the RVWMO Memory Model}
\label{sec:rvwmo}

{\em 全局内存次序}，即所有硬件线程所产生的内存操作的总体次序，据此定义了RVWMO内存模型。总的来说，一个多线程程序有许多种不同可能的执行，而每种执行有其自己相应的全局内存次序。
% The RVWMO memory model is defined in terms of the {\em global memory order}, a total ordering of the memory operations produced by all harts.
% In general, a multithreaded program has many different possible executions, with each execution having its own corresponding global memory order.

全局内存次序定义在由内存指令生成的原始的加载和存储操作之上。然后它将受到本章余下部分定义的约束的限制。任何满足所有内存模型约束的执行都是合法的执行（至少在内存模型所关注的方面如此）。
% The global memory order is defined over the primitive load and store operations generated by memory instructions.
% It is then subject to the constraints defined in the rest of this chapter.
% Any execution satisfying all of the memory model constraints is a legal execution (as far as the memory model is concerned).

\subsection*{内存模型原语}
% \subsection*{Memory Model Primitives}
\label{sec:rvwmo:primitives}
在内存操作上的{\em 程序次序}反映了生成每个加载和存储的指令在硬件线程的动态指令流中的次序；即，简单有序处理器将执行的该硬件线程的指令的次序。
% The {\em program order} over memory operations reflects the order in which the instructions that generate each load and store are logically laid out in that hart's dynamic instruction stream; i.e., the order in which a simple in-order processor would execute the instructions of that hart.

内存访问指令造成了内存操作。{\em 内存操作}可以是一个{\em 加载操作}、{\em 存储操作}，或者是二者同时。
所有的内存操作都是“单拷贝原子”的：它们可以永远不会被观察到处于一种部分完成的状态。
% Memory-accessing instructions give rise to {\em memory operations}.
% A memory operation can be either a {\em load operation}, a {\em store operation}, or both simultaneously.
% All memory operations are single-copy atomic: they can never be observed in a partially complete state.

在RV32GC和RV64GC的指令之中，每个对齐的内存指令都确切造成一次内存操作和两个异常。
首先，一次不成功的SC指令不会造成任何内存操作。第二，如果XLEN$<$64，就像~\ref{fld_fsd}节中所陈述的和下面澄清的那样，那么FLD和FSD指令每次可以造成多个内存操作。一个对齐的AMO指令造成单次内存操作，它同时是一个加载操作和一个存储操作。
% Among instructions in RV32GC and RV64GC, each aligned memory instruction gives rise to exactly one memory operation, with two exceptions.
% First, an unsuccessful SC instruction does not give rise to any memory operations.
% Second, FLD and FSD instructions may each give rise to multiple memory operations if XLEN$<$64, as stated in Section~\ref{fld_fsd} and clarified below.
% An aligned AMO gives rise to a single memory operation that is both a load operation and a store operation simultaneously.

\begin{commentary}
  RV128基础指令集中的指令和诸如V（向量）和P（SMID）的未来ISA扩展中的指令可能造成多个内存操作。然而对于这些扩展的内存模型还没有被规范化。
  % Instructions in the RV128 base instruction set and in future ISA extensions such as V (vector) and P (SIMD) may give rise to multiple memory operations.  However, the memory model for these extensions has not yet been formalized.
\end{commentary}

未对齐的加载或存储指令可能被分解为任意粒度的组件内存操作的集合。对于XLEN$<$64的FLD或FSD指令也可能被分解为任意粒度的组件内存操作的集合。
通过这样的指令生成的内存操作并不按照相互间的程序次序被排序，但是它们可以根据“在程序次序中位于先前或后续指令所生成的内存操作”来正常地排序。原子扩展“A”完全不需要执行环境提供未对齐的原子指令；
然而，如果通过“Zam”扩展支持未对齐的原子指令，那么LR、SC和AMO可以按照未对齐原子指令的原子性公理的约束而被分解，该约束定义在第~\ref{sec:zam}章中。
% A misaligned load or store instruction may be decomposed into a set of component memory operations of any granularity.
% An FLD or FSD instruction for which XLEN$<$64 may also be decomposed into a set of component memory operations of any granularity.
% The memory operations generated by such instructions are not ordered with respect to each other in program order, but they are ordered normally with respect to the memory operations generated by preceding and subsequent instructions in program order.
% The atomics extension ``A'' does not require execution environments to support misaligned atomic instructions at all; however, if misaligned atomics are supported via the ``Zam'' extension, LRs, SCs, and AMOs may be decomposed subject to the constraints of the atomicity axiom for misaligned atomics, which is defined in Chapter~\ref{sec:zam}.

\begin{commentary}
  将未对齐内存操作分解下到字节粒度有利于在原本不支持未对齐访问的实现上进行模拟。例如，这种实现可能简单地逐个迭代未对齐的访问的字节。
  % The decomposition of misaligned memory operations down to byte granularity facilitates emulation on implementations that do not natively support misaligned accesses.
  % Such implementations might, for example, simply iterate over the bytes of a misaligned access one by one.
\end{commentary}

如果在程序次序中，LR先于SC，并且在它们之间没有其它的LR或SC指令，那么LR指令和SC指令被称作成对的；对应的内存操作也被称为成对的（除了在SC失败的情况中，那里没有产生存储操作）。决定一个SC是否必定成功、可能成功、或者必定失败的条件的完整列表定义在~\ref{sec:lrsc}节中。
% An LR instruction and an SC instruction are said to be {\em paired} if the LR precedes the SC in program order and if there are no other LR or SC instructions in between; the corresponding memory operations are said to be paired as well (except in case of a failed SC, where no store operation is generated).
% The complete list of conditions determining whether an SC must succeed, may succeed, or must fail is defined in Section~\ref{sec:lrsc}.

加载和存储操作也可以从下列集合中携带一个或多个次序注释：“acquire-RCpc”、“acquire-RCsc”、“release-RCpc”和“release-RCsc”。
一个设置了{\em aq}的AMO或LR指令具有“acquire-RCsc”注释。
一个设置了{\em rl}的AMO或SC指令具有“releaseRCsc”注释。
同时设置了{\em aq}和{\em rl}的AMO、LR或SC指令也同时有“acquire-RCsc”和“release-RCsc”注释。
% Load and store operations may also carry one or more ordering annotations from the following set: ``acquire-RCpc'', ``acquire-RCsc'', ``release-RCpc'', and ``release-RCsc''.
% An AMO or LR instruction with {\em aq} set has an ``acquire-RCsc'' annotation.
% An AMO or SC instruction with {\em rl} set has a ``release-RCsc'' annotation.
% An AMO, LR, or SC instruction with both {\em aq} and {\em rl} set has both ``acquire-RCsc'' and ``release-RCsc'' annotations.

为了方便，我们使用术语“acquire注释”来指代一个acquire-RCpc注释或者一个acquire-RCsc注释。
类似地，用“release注释”指代一个release-RCpc注释或者一个release-RCsc注释。
用“RCpc注释”指代一个acquire-RCpc注释或者一个releaseRCpc注释。
用“RCsc注释”指代一个acquire-RCsc注释或者一个release-RCsc注释。
% For convenience, we use the term ``acquire annotation'' to refer to an acquire-RCpc annotation or an acquire-RCsc annotation.
% Likewise, a ``release annotation'' refers to a release-RCpc annotation or a release-RCsc annotation.
% An ``RCpc annotation'' refers to an acquire-RCpc annotation or a release-RCpc annotation.
% An ``RCsc annotation'' refers to an acquire-RCsc annotation or a release-RCsc annotation.

\begin{commentary}
  在内存模型文献中，术语“RCpc”代表带有与处理器一致的同步操作的释放一致性，而术语“RCsc”代表带有顺序一致的同步操作的释放一致性~\cite{Gharachorloo90memoryconsistency}。
  % In the memory model literature, the term ``RCpc'' stands for release consistency with processor-consistent synchronization operations, and the term ``RCsc'' stands for release consistency with sequentially consistent synchronization operations~\cite{Gharachorloo90memoryconsistency}.

  虽然在文献中对于acquire注释和release注释有许多不同的定义，在RVWMO的上下文中，这些术语由保留的程序次序规则\ref{ppo:acquire}－\ref{ppo:rcsc}简洁而完整地定义。
  % While there are many different definitions for acquire and release annotations in the literature, in the context of RVWMO these terms are concisely and completely defined by Preserved Program Order rules \ref{ppo:acquire}--\ref{ppo:rcsc}.

  “RCpc”注释目前只被用在各标准扩展“Ztso”（第~\ref{sec:ztso}章）被隐式地分配给每个内存访问时。甚至，尽管ISA目前既不包括原生的“加载-获取”或者“存储-释放”指令，也因此不包括其中的RCpc变量，RVWMO模型本身被设计为向前兼容的，可以在未来的扩展中把上面的任何或者所有的潜在的附件兼容进ISA中。
  % ``RCpc'' annotations are currently only used when implicitly assigned to every memory access per the standard extension ``Ztso'' (Chapter~\ref{sec:ztso}).  Furthermore, although the ISA does not currently contain native load-acquire or store-release instructions, nor RCpc variants thereof, the RVWMO model itself is designed to be forwards-compatible with the potential addition of any or all of the above into the ISA in a future extension.
\end{commentary}

\subsection*{句法依赖}
% \subsection*{Syntactic Dependencies}
\label{sec:memorymodel:dependencies}
RVWMO内存模型的定义部分依赖于句法依赖的概念，后者定义如下。
% The definition of the RVWMO memory model depends in part on the notion of a syntactic dependency, defined as follows.

在定义的依赖的上下文中，“寄存器”或者指代一个完整的通用目的寄存器，或者指代CSR的某些部分，或者指代一个完整的CSR。通过CSR追踪的依赖的粒度特定于每个CSR，并在~\ref{sec:csr-granularity}节中定义。
% In the context of defining dependencies, a ``register'' refers either to an entire general-purpose register, some portion of a CSR, or an entire CSR.  The granularity at which dependencies are tracked through CSRs is specific to each CSR and is defined in Section~\ref{sec:csr-granularity}.

句法依赖的定义依据于指令的源寄存器、指令的目的寄存器，和指令从它们的{\em 源寄存器}到{\em 目的寄存器}携带依赖的方式。本节提供了一个所有这些术语的通用的定义；然而，~\ref{sec:source-dest-regs}节提供了每个指令的详细信息的一个完整的列表。
% Syntactic dependencies are defined in terms of instructions' {\em source registers}, instructions' {\em destination registers}, and the way instructions {\em carry a dependency} from their source registers to their destination registers.
% This section provides a general definition of all of these terms; however, Section~\ref{sec:source-dest-regs} provides a complete listing of the specifics for each instruction.

总体上，对于一个指令$i$，如果满足任意下列条件，{\em 源寄存器}是寄存器$r$，而不是{\tt x0}：
% In general, a register $r$ other than {\tt x0} is a {\em source register} for an instruction $i$ if any of the following hold:
\begin{itemize}
  \item 在$i$的操作码中，{\em rs1}、{\em rs2}或者{\em rs3}被设置为$r$  % In the opcode of $i$, {\em rs1}, {\em rs2}, or {\em rs3} is set to $r$
  \item $i$是一个CSR指令，并且在$i$的操作码中，{\em csr}被设置为$r$（除非$i$是CSRRW或CSRRWI，并且{\em rd}被设置为{\em x0}）  % $i$ is a CSR instruction, and in the opcode of $i$, {\em csr} is set to $r$, unless $i$ is CSRRW or CSRRWI and {\em rd} is set to {\tt x0}
  \item $r$是一个CSR，且对于$i$，$r$是一个隐式的源寄存器，就像~\ref{sec:source-dest-regs}节中定义的那样  % $r$ is a CSR and an implicit source register for $i$, as defined in Section~\ref{sec:source-dest-regs}
  \item 对于$i$，$r$是一个作为另一个源寄存器的别名的CSR % $r$ is a CSR that aliases with another source register for $i$
\end{itemize}
内存指令也进一步指定了哪个源寄存器是{\em 地址源寄存器}，以及哪个是{\em 数据源寄存器}。
% Memory instructions also further specify which source registers are {\em address source registers} and which are {\em data source registers}.

总体上，对于一个指令$i$，如果满足任意下列条件，{\em 目的寄存器}是寄存器$r$，而不是{\em x0}：
% In general, a register $r$ other than {\tt x0} is a {\em destination register} for an instruction $i$ if any of the following hold:
\begin{itemize}
  \item 在i的操作码中，rd被设置为r  % In the opcode of $i$, {\em rd} is set to $r$
  \item $i$是一个CSR指令，且在$i$的操作码中，{\em csr}被设置为$r$（除非$i$是CSRRS或CSRRC，并且{\em rs1}被设置为{\em x0}；或者$i$是CSRRI或CSRRCI，并且uimm[4:0]被设置为0）  % $i$ is a CSR instruction, and in the opcode of $i$, {\em csr} is set to $r$, unless $i$ is CSRRS or CSRRC and {\em rs1} is set to {\tt x0} or $i$ is CSRRSI or CSRRCI and uimm[4:0] is set to zero.
  \item $r$是一个CSR，并且对于$i$，$r$是一个隐式的目的寄存器，正如~\ref{sec:source-dest-regs}节中定义的那样  % $r$ is a CSR and an implicit destination register for $i$, as defined in Section~\ref{sec:source-dest-regs}
  \item 对于$i$，$r$是一个作为另一个目的寄存器的别名的CSR  % $r$ is a CSR that aliases with another destination register for $i$
\end{itemize}

大多数非内存指令携带有从它们的每个源寄存器到它们的每个目的寄存器的依赖。然而，对于这个规则是有例外的；见~\ref{sec:source-dest-regs}节。
% Most non-memory instructions {\em carry a dependency} from each of their source registers to each of their destination registers.
% However, there are exceptions to this rule; see Section~\ref{sec:source-dest-regs}

如果满足下列之一，通过$i$的目的寄存器$s$和$j$的源寄存器$r$，指令$j$有一个关于指令$i$的{\em 句法依赖}：
% Instruction $j$ has a {\em syntactic dependency} on instruction $i$ via destination register $s$ of $i$ and source register $r$ of $j$ if either of the following hold:
\begin{itemize}
  \item $s$与$r$相同，并且按程序次序，在i和j之间没有指令把$r$作为目的寄存器  % $s$ is the same as $r$, and no instruction program-ordered between $i$ and $j$ has $r$ as a destination register
  \item 按程序次序，在$i$和$j$之间有指令$m$，使得满足所有下列条件： % There is an instruction $m$ program-ordered between $i$ and $j$ such that all of the following hold:
    \begin{enumerate}
      \item 通过目的寄存器$q$和源寄存器$r$，$j$有一个关于$m$的句法依赖  % $j$ has a syntactic dependency on $m$ via destination register $q$ and source register $r$
      \item 通过目的寄存器$s$和源寄存器$p$，$m$有一个关于$i$的句法依赖   % $m$ has a syntactic dependency on $i$ via destination register $s$ and source register $p$
      \item $m$携带有从$p$到$q$的依赖  % $m$ carries a dependency from $p$ to $q$
    \end{enumerate}
\end{itemize}

最后，在下面的定义中，$a$和$b$是两个内存操作，而$i$和$j$是分别生成$a$和$b$的指令。
% Finally, in the definitions that follow, let $a$ and $b$ be two memory operations, and let $i$ and $j$ be the instructions that generate $a$ and $b$, respectively.

$b$有一个关于a的{\em 句法地址依赖}，如果$r$是$j$的一个地址源寄存器，而$j$通过源寄存器$r$有一个关于$i$的句法依赖
% $b$ has a {\em syntactic address dependency} on $a$ if $r$ is an address source register for $j$ and $j$ has a syntactic dependency on $i$ via source register $r$

$b$有一个关于$a$的{\em 句法数据依赖}，如果$b$是一个存储操作，$r$是$j$的一个数据源寄存器，且$j$通过源寄存器$r$有一个关于$i$的句法依赖
$b$ has a {\em syntactic data dependency} on $a$ if $b$ is a store operation, $r$ is a data source register for $j$, and $j$ has a syntactic dependency on $i$ via source register $r$

$b$有一个关于$a$的{\em 句法控制依赖}，如果按程序次序，在$i$和$j$之间有一个指令$m$，使$m$是一个分支、或者间接跳转，并且$m$有一个关于$i$的句法依赖。
% $b$ has a {\em syntactic control dependency} on $a$ if there is an instruction $m$ program-ordered between $i$ and $j$ such that $m$ is a branch or indirect jump and $m$ has a syntactic dependency on $i$.

\begin{commentary}
  总的来说，非AMO加载指令没有数据源寄存器，而无条件非AMO存储指令没有目的寄存器。然而，一个成功的SC指令被认为在{\em rd}中指定了寄存器作为目的寄存器，并因此对于一条指令，可能有一个关于程序次序中先于它的成功SC指令的句法依赖。
  % Generally speaking, non-AMO load instructions do not have data source registers, and unconditional non-AMO store instructions do not have destination registers.  However, a successful SC instruction is considered to have the register specified in {\em rd} as a destination register, and hence it is possible for an instruction to have a syntactic dependency on a successful SC instruction that precedes it in program order.
\end{commentary}

\subsection*{保留的程序次序}
% \subsection*{Preserved Program Order}
对于任意给定的程序执行，全局内存次序遵循着各个硬件线程的内存次序中的一部分（但不是所有）。必须被全局内存次序所遵循的程序次序子集被称为{\em 保留的程序次序}。
% The global memory order for any given execution of a program respects some but not all of each hart's program order.
% The subset of program order that must be respected by the global memory order is known as {\em preserved program order}.

% \newcommand{\ppost}{$b$ is a store, and $a$ and $b$ access overlapping memory addresses}
% \newcommand{\ppofence}{There is a FENCE instruction that orders $a$ before $b$}
% \newcommand{\ppoacquire}{$a$ has an acquire annotation}
% \newcommand{\pporelease}{$b$ has a release annotation}
% \newcommand{\pporcsc}{$a$ and $b$ both have RCsc annotations}
% \newcommand{\ppoamoforward}{$a$ is generated by an AMO or SC instruction, $b$ is a load, and $b$ returns a value written by $a$}
% \newcommand{\ppoaddr}{$b$ has a syntactic address dependency on $a$}
% \newcommand{\ppodata}{$b$ has a syntactic data dependency on $a$}
% \newcommand{\ppoctrl}{$b$ is a store, and $b$ has a syntactic control dependency on $a$}
% \newcommand{\ppopair}{$a$ is paired with $b$}
% \newcommand{\ppordw}{$a$ and $b$ are loads, $x$ is a byte read by both $a$ and $b$, there is no store to $x$ between $a$ and $b$ in program order, and $a$ and $b$ return values for $x$ written by different memory operations}
% \newcommand{\ppoaddrdatarfi}{$b$ is a load, and there exists some store $m$ between $a$ and $b$ in program order such that $m$ has an address or data dependency on $a$, and $b$ returns a value written by $m$}
% \newcommand{\ppoaddrpo}{$b$ is a store, and there exists some instruction $m$ between $a$ and $b$ in program order such that $m$ has an address dependency on $a$}
%\newcommand{\ppoctrlcfence}{$a$ and $b$ are loads, $b$ has a syntactic control dependency on $a$, and there exists a {\tt fence.i} between the branch used to form the control dependency and $b$ in program order}
%\newcommand{\ppoaddrpocfence}{$a$ is a load, there exists an instruction $m$ which has a syntactic address dependency on $a$, and there exists a {\tt fence.i} between $m$ and $b$ in program order}

保留的程序次序的完整定义如下（且注意AMO是同时进行加载和存储）：在保留的程序次序中，内存操作$a$先于内存操作$b$（并因此在全局内存次序中也是如此），如果以程序次序$a$先于$b$，$a$和$b$都访问常规的主内存（而不是I/O区域），并且满足任何下列：
% The complete definition of preserved program order is as follows (and note that AMOs are simultaneously both loads and stores):
% memory operation $a$ precedes memory operation $b$ in preserved program order (and hence also in the global memory order) if $a$ precedes $b$ in program order, $a$ and $b$ both access regular main memory (rather than I/O regions), and any of the following hold:

\begin{itemize}
  \item 重叠地址次序： % Overlapping-Address Orderings:
    \begin{enumerate}
      \item\label{ppo:->st} \ppost
      \item\label{ppo:rdw} \ppordw
      \item\label{ppo:amoforward} \ppoamoforward
    \end{enumerate}
  \item 显示同步  % Explicit Synchronization
    \begin{enumerate}[resume]
      \item\label{ppo:fence} \ppofence
      \item\label{ppo:acquire} \ppoacquire
      \item\label{ppo:release} \pporelease
      \item\label{ppo:rcsc} \pporcsc
      \item\label{ppo:pair} \ppopair
    \end{enumerate}
  \item 句法依赖 %  Syntactic Dependencies
    \begin{enumerate}[resume]
      \item\label{ppo:addr} \ppoaddr
      \item\label{ppo:data} \ppodata
      \item\label{ppo:ctrl} \ppoctrl
    \end{enumerate}
  \item 流水线依赖  % Pipeline Dependencies
    \begin{enumerate}[resume]
      \item\label{ppo:addrdatarfi} \ppoaddrdatarfi
      \item\label{ppo:addrpo} \ppoaddrpo
      %\item\label{ppo:ctrlcfence} \ppoctrlcfence
      %\item\label{ppo:addrpocfence} \ppoaddrpocfence
    \end{enumerate}
\end{itemize}

\subsection*{内存模型公理}
% \subsection*{Memory Model Axioms}

只有当存在一个符合保留的程序次序并且满足{\em 加载值公理}、{\em 原子性公理}和{\em 进度公理}的全局内存次序时，RISC-V程序的执行遵循RVWMO内存一致性模型。
% An execution of a RISC-V program obeys the RVWMO memory consistency model only if there exists a global memory order conforming to preserved program order and satisfying the {\em load value axiom}, the {\em atomicity axiom}, and the {\em progress axiom}.

% \newcommand{\loadvalueaxiom}{
%   每个加载$i$的各个位所返回的值，由下列存储中在全局内存次序中最近的那个写到该位：
%   % Each byte of each load $i$ returns the value written to that byte by the store that is the latest in global memory order among the following stores:
%   \begin{enumerate}
%     \item 写该位，并且在全局内存次序中先于$i$的存储  % Stores that write that byte and that precede $i$ in the global memory order
%     \item 写该位，并且在程序次序中先于$i$的存储  % Stores that write that byte and that precede $i$ in program order
%   \end{enumerate}
% }

% \newcommand{\atomicityaxiom}{If $r$ and $w$ are paired load and store operations generated by aligned LR and SC instructions in a hart $h$, $s$ is a store to byte $x$, and $r$ returns a value written by $s$, then $s$ must precede $w$ in the global memory order, and there can be no store from a hart other than $h$ to byte $x$ following $s$ and preceding $w$ in the global memory order.}

% \newcommand{\progressaxiom}{No memory operation may be preceded in the global memory order by an infinite sequence of other memory operations.}

\paragraph{加载值公理}
\label{rvwmo:ax:load}
\loadvalueaxiom

\paragraph{原子性公理}
\label{rvwmo:ax:atom}
\atomicityaxiom

\begin{commentary}
  \nameref{rvwmo:ax:atom}理论上支持不同宽度的LR/SC对，以及不匹配的地址，因为允许实现在这种情况中使SC操作成功。然而，在实际中，我们希望这种式样是稀有的，并且不鼓励使用它们。
  % The \nameref{rvwmo:ax:atom} theoretically supports LR/SC pairs of different widths and to mismatched addresses, since implementations are permitted to allow SC operations to succeed in such cases.  However, in practice, we expect such patterns to be rare, and their use is discouraged.
\end{commentary}

\paragraph{进度公理}
\label{rvwmo:ax:prog}
\progressaxiom

\input{dep-table}
