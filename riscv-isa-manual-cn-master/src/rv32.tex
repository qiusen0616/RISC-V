\chapter{RV32I 基础整数指令集，2.1版本}
\label{rv32}

本章介绍 RV32I 基础整数指令集。

\begin{commentary}

  RV32I的设计要足以能够形成一个编译器的目标码，并足以能够支持现代操作系统环境。
  该ISA也被设计为在最小化的实现中降低对硬件的需求。RV32I包含40条各不相同的指令——尽管在某个简单的实现中，
  可能会用一个总是陷入的SYSTEM硬件指令来覆盖ECALL/EBREAK指令，以及可能会把FENCE指令实现为一个NOP，
  从而把基础指令数目减少到总计38条。RV32I可以模拟几乎任何其它的ISA扩展（除了A扩展，因为它需要原子性的额外硬件支持）

  实际上，一个包含了机器模式（machine-mode）特权架构的硬件实现还将需要6个CSR指令。

  对于教学目的来说，基础整数ISA的子集可能是非常有用的，
  但是“基础”已经定义了，应当尽量不要在一个真实的硬件实现中对基础整数ISA进行子集化——除非想省略掉对非对齐内存访问的支持，
  或者想把所有的SYSTEM指令视为一个单独的陷入。
\end{commentary}

\begin{commentary}

标准RISC-V汇编语言语法的文档在《汇编程序员手册》~\cite{riscv-asm-manual}中。
\end{commentary}

\begin{commentary}

大多数对RV32I的注解也适用于RV64I基础指令集。
\end{commentary}

\section{基础整数 ISA 的编程模型}

表~\ref{gprs}显示了基础整数ISA的非特权状态。
对于RV32I，32个{\tt x}寄存器每个都是32位宽，也就是说，XLEN＝32。
寄存器{\tt x0}的所有位都被硬布线为0。通用目的寄存器{\tt x1}-{\tt x31}持有数值，
这些值被各种指令解释为各种布尔值的集合、或者二进制有符号整数，或者无符号整数的二补码。

还有一个额外的非特权寄存器：程序计数器{\tt pc}，保存当前指令的地址。

\begin{figure}[H]
{\footnotesize
\begin{center}
\begin{tabular}{p{2in}}
\instbitrange{XLEN-1}{0}                                  \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ \ \ x0 / zero}}      \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x1\ \ \ \ \ }}            \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x2\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x3\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x4\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x5\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x6\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x7\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x8\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ \ x9\ \ \ \ \ }}       \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x10\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x11\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x12\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x13\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x14\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x15\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x16\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x17\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x18\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x19\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x20\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x21\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x22\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x23\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x24\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x25\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x26\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x27\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x28\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x29\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x30\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{\ \ \ x31\ \ \ \ \ }}        \\ \cline{1-1}
\multicolumn{1}{c}{XLEN}                                  \\

\instbitrange{XLEN-1}{0}                                  \\ \cline{1-1}
\multicolumn{1}{|c|}{\reglabel{pc}}                         \\ \cline{1-1}
\multicolumn{1}{c}{XLEN}                                  \\
\end{tabular}
\end{center}
}
\caption{RISC-V基础非特权整数寄存器状态}
\label{gprs}
\end{figure}

\begin{commentary}

  在基础整数ISA中没有专门的栈指针或子程序返回地址链接的寄存器；
  指令编码允许任何的{\tt x}寄存器被用于这些目的。然而，标准软件调用约定使用寄存器{\tt x1}来持有调用的返回地址，
  同时寄存器{\tt x5}可用作备选的链接寄存器。标准调用约定使用寄存器{\tt x2}作为栈指针。

  硬件可能选择加速函数调用并使用{\tt x1}或{\tt x5}返回。见JAL和JALR指令的描述。

  压缩16位指令格式是围绕着{\tt x1}是返回地址寄存器，而{\tt x2}是栈指针的假设设计的。
  使用其它约定（非标准约定）的软件虽然可以正确地执行，但是可能会让导致更大的代码尺寸。

\end{commentary}

\begin{commentary}

  架构寄存器的可用数目对代码尺寸、性能、和能量消耗有很大的影响。
  尽管16个寄存器对于一个整数ISA来说运行已编译代码理应是足够的，
  但是使用3-地址格式，在16位指令中编码一个带有16个寄存器的完整ISA仍然是不可能的。
  尽管2-地址格式是可能的，但是将增加指令数量并降低效率。我们希望避免中间指令尺寸（例如Xtensa的24位指令），
  以简化基础硬件实现。一旦采用了32位指令尺寸，就可以直接支持32个整数寄存器。
  更大数目的整数寄存器也对高性能代码的性能提升有帮助，可以促成循环展开、软件流水线和缓存平铺的广泛使用。

  由于这些原因，我们为RV32I选择了32个整数寄存器作为约定数量。
  动态寄存器使用往往由一些频繁访问的寄存器所控制，而 regfile 的实现可以优化以减少对频繁访问寄存器的访问能耗~\cite{jtseng:sbbci}。
  可选的压缩16位指令格式大多数只访问8个寄存器，并因此可以提供一种稠密的指令编码；
  而额外的指令集扩展，如果愿意，可能支持更大的寄存器空间（或者是扁平的，或者是分层的）。

  对于资源受限的嵌入式应用，我们已经定义了RV32E子集，它只有16个寄存器（第~\ref{rv32e}章）。
\end{commentary}

\section{基础指令格式}

在基础RV32I ISA中，有四个核心指令格式（R/I/S/U），如图~\ref{fig:baseinstformats}所示。
所有这四个格式都是32位固定长度。
基础ISA有IALIGN＝32意味着指令必须在内存中对齐到四字节的边界。
如果在执行分支或无条件跳转时，目标地址没有按IALIGN位对齐，将生成一个指令地址未对齐的异常。
这个异常由分支或跳转指令汇报，而不是目标指令。对于还没有被执行的条件分支，不会生成指令地址未对齐异常。

\begin{commentary}

  当加入了16位长度的指令扩展或者其它长度为16位奇数倍的扩展（即，IALIGN＝16）时，
  对基础ISA指令的对齐约束被放宽到按双字节边界对齐。

  导致指令未对齐的分支或跳转，将汇报指令地址未对齐异常，以帮助调试，同时有助于简化IALIGN＝32的系统硬件设计，
  因为这是唯一可能发生未对齐的情况。
\end{commentary}

解码一个保留指令的行为是“未指定的”（UNSPECIFIED）。

\begin{commentary}
  
  一些平台下，解码为标准使用而保留的操作码会引发一个非法指令异常。其它平台可能允许保留的操作码空间被用于非合规的扩展。
\end{commentary}

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{1.2in}@{}p{0.8in}@{}p{0.8in}@{}p{0.6in}@{}p{0.8in}@{}p{1in}l}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\cline{1-6}
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
R-类型 \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{2}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
I-类型 \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} &
S-类型 \\
\cline{1-6}
\\
\cline{1-6}
\multicolumn{4}{|c|}{imm[31:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
U-类型 \\
\cline{1-6}
\end{tabular}
\end{center}
\caption{RISC-V 基础指令格式。 每个立即数子域都用正被产生的立即数值中的位位置（imm[{\em x}]）的标签标记，
而不是像通常做的那样，用指令立即数域中的位位置。}
\label{fig:baseinstformats}
\end{figure}

为了简化解码，所有格式中，RISC-V ISA在相同的位置保存源寄存器（{\em rs1}和{\em rs2}）和目的寄存器（{\em rd}）。
除了CSR指令（第~\ref{csrinsts}章）中使用的5位立即数，立即数总是符号扩展的，并且通常在指令中被封装在最左端的可用位，
且被提前分配以减少硬件复杂度。特别地，为了加速符号扩展的电路，所有立即数的符号位总是在指令的位31处。

\begin{commentary}

  在实现层面中，解码寄存器标识符通常都是非常关键的路径，因此选择指令格式时，在所有格式中，
  寄存器标识符都保存在相同的位置上；作为代价，不得不跨格式移动立即数位（一个分享自RISC第四版RISC-IV的属性，又称SPUR~\cite{spur-jsscc1989}）。

  实际上，大多数立即数或者比较小，或者需要所有的XLEN位。
  我们选择了一种不对称的立即数分割方法（常规指令中的12位加上一个特殊的20位的“加载上位立即数（load-upper-immediate）”指令）
  来为常规指令增加可用的编码空间。

  立即数是符号扩展的，因为对于某些立即数，我们没有观察到使用零扩展的收益（像在MIPS ISA中），并且想保持ISA尽可能地简单。
\end{commentary}

\section{立即数编码变量}

基于对立即数的处理，还有两个指令格式的变体（B/J），如图~\ref{fig:baseinstformatsimm}所示。

\begin{figure}[h]
\begin{small}
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{0.3in}@{}p{0.8in}@{}p{0.6in}@{}p{0.18in}@{}p{0.7in}@{}p{0.6in}@{}p{0.6in}@{}p{0.3in}@{}p{0.5in}l}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{25} &
\instbitrange{24}{21} &
\multicolumn{1}{c}{\instbit{20}} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{8} &
\multicolumn{1}{c}{\instbit{7}} &
\instbitrange{6}{0} \\
\cline{1-9}
\multicolumn{2}{|c|}{funct7} &
\multicolumn{2}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
R-类型 \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{4}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
I-类型 \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{2}{|c|}{imm[11:5]} &
\multicolumn{2}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{2}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} &
S-类型 \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{1}{|c|}{imm[12]} &
\multicolumn{1}{c|}{imm[10:5]} &
\multicolumn{2}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{1}{c|}{opcode} &
B-类型 \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{6}{|c|}{imm[31:12]} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
U-类型 \\
\cline{1-9}
\\
\cline{1-9}
\multicolumn{1}{|c|}{imm[20]} &
\multicolumn{2}{c|}{imm[10:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{2}{c|}{imm[19:12]} &
\multicolumn{2}{c|}{rd} &
\multicolumn{1}{c|}{opcode} &
J-类型 \\
\cline{1-9}
\end{tabular}
\end{center}
\end{small}
\caption{显式立即数的RISC-V基础指令格式。}
\label{fig:baseinstformatsimm}
\end{figure}

S格式和B格式之间唯一的不同是，在B格式中，12位立即数域被用于以2的倍数对分支的偏移量进行编码。
将中间位（imm[10:1]）和符号位放置在固定的位置，同时S格式中的最低位（inst[7]）以B格式对高序位进行编码，
而不是像传统的做法那样，在硬件中把编码指令立即数中的所有位直接左移一位。

类似地，U格式和J格式之间唯一的不同是，20位立即数向左移位12位形成U格式立即数，而向左移1位形成J格式立即数。
选择U格式和J格式立即数中的指令位的位置，是为了与其它格式和彼此之间有最大程度的交叠。

图~\ref{fig:immtypes}显示了由每个基础指令格式产生的立即数，并用标记显示了立即数值的各个位是由哪个指令位（inst[{\em y}\,]）所产生的。

\begin{figure}[h]
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{p{0.2in}@{}p{1.2in}@{}p{1.0in}@{}p{0.2in}@{}p{0.7in}@{}p{0.7in}@{}p{0.2in}l}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{20} &
\instbitrange{19}{12} &
\multicolumn{1}{c}{\instbit{11}} &
\instbitrange{10}{5} &
\instbitrange{4}{1} &
\multicolumn{1}{c}{\instbit{0}} &
\\
\cline{1-7}
\multicolumn{4}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[24:21]} &
\multicolumn{1}{c|}{inst[20]} &
I-立即数 \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{4}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[11:8]} &
\multicolumn{1}{c|}{inst[7]} &
S-立即数 \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{3}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[7]} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[11:8]} &
\multicolumn{1}{c|}{0} &
B-立即数 \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{1}{|c|}{inst[31]} &
\multicolumn{1}{c|}{inst[30:20]} &
\multicolumn{1}{c|}{inst[19:12]} &
\multicolumn{4}{c|}{--- 0 ---} &
U-立即数 \\
\cline{1-7}
\\
\cline{1-7}
\multicolumn{2}{|c|}{--- inst[31] ---} &
\multicolumn{1}{c|}{inst[19:12]} &
\multicolumn{1}{c|}{inst[20]} &
\multicolumn{1}{c|}{inst[30:25]} &
\multicolumn{1}{c|}{inst[24:21]} &
\multicolumn{1}{c|}{0} &
J-立即数 \\
\cline{1-7}
\end{tabular}
\end{center}
\caption{由RISC-V指令产生的立即数的类型。 用构造了它们值的指令位对域进行了标记。符号扩展总是使用inst[31]。}
\label{fig:immtypes}
\end{figure}

\begin{commentary}
符号扩展是最关键的立即数操作之一（特别是对XLEN$>$32），
而在RISC-V中，所有立即数的符号位总是保持在指令的位31，以允许符号扩展与指令解码并行处理。

虽然更加复杂的实现可能带有用于分支和跳转计算的独立加法器，
并且，因为在不同指令类型之间，保持立即数位的位置不变并不能从中获得好处，所以我们希望减少最简单实现的硬件开销。
通过旋转由B格式和J格式立即数编码的指令中的位，而不是使用动态的硬件多路复用器（mux），来将立即数扩大2倍，
我们减少了大约一半的指令符号扇出（fanout）和立即数多路复用的开销。加扰（scrambled）立即数编码将对静态编译或事前编译添加微不足道的时间。
为了指令的动态生成，虽然有一些小小的额外的开销，但是最常见的短转向分支却有了直接的立即数编码。
\end{commentary}

\section{整数运算指令}

大多数整数运算指令操作所有XLEN位的值，这些值保存在整数寄存器文件中。
整数运算指令或者被编码为使用I类型格式的寄存器-立即数操作，或者被编码为使用R类型格式的寄存器-寄存器操作。
对于寄存器-立即数指令和寄存器-寄存器指令，目的寄存器都是寄存器{\em rd}。整数运算指令不会引发算术异常。

\begin{commentary}
我们没有在整数指令集中包括对于在整数算术操作时进行溢出检查的特殊指令集的支持，
因为许多溢出检查可以使用RISC-V分支低成本地实现。
对于无符号加法的溢出检查，只需要在加法之后执行一条额外的分支指令：
\verb! add t0, t1, t2; bltu t0, t1, overflow!.

对于有符号加法，如果一个操作数的符号是已知的，溢出检查只需要在加法之后执行一条分支：
\verb! addi t0, t1, +imm; blt t0, t1, overflow!.  
这覆盖了带有一个立即操作数的加法的通常情况。

对于一般的有符号加法，在加法之后需要三条额外的指令，利用了这样一个事实：当且仅当某个操作数是负数时，和应当小于另一个操作数。
\begin{verbatim}
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
\end{verbatim}
在RV64I中，32位有符号加法的检查可以被进一步优化，通过比较在操作数上进行ADD和ADDW的结果实现。
\end{commentary}

\subsubsection*{整数寄存器 - 立即数指令}
\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
I-立即数[11:0] & src & ADDI/SLTI[U]  & dest & OP-IMM \\
I-立即数[11:0] & src & ANDI/ORI/XORI & dest & OP-IMM \\
\end{tabular}
\end{center}
ADDI将符号扩展的12位立即数加到寄存器{\em rs1}上。
简单地将结果的低XLEN位当作结果，而忽略了算数溢出。ADDI {\em rd, rs1, 0} 被用于实现 MV {\em rd, rs1} 汇编器伪指令。

如果寄存器{\em rs1}小于符号扩展的立即数（当二者都被视为有符号数时），
SLTI（小于立即数时置1）指令把值1放到寄存器{\em rd}中；否则，该指令把0写入{\em rd}中。
SLTIU与之相似，但是将两个值作为无符号数比较（也就是说，前者会把立即数按符号扩展到XLEN位，而后者会将其视为无符号数）。
注意，如果{\em rs1}等于0，那么SLTIU {\em rd, rs1, 1} 会把{\em rd}设置为1，否则会把{\em rd}设置为0（汇编器伪指令SEQZ {\em rd, rs}）。

ANDI、ORI、XORI是在寄存器{\em rs1}和符号扩展的12位立即数上执行按位AND、OR和XOR，
并把结果放入{\em rd}的逻辑操作。注意，XORI {\em rd, rs1, -1} 对寄存器{\em rs1}执行按位逻辑反转（汇编器伪指令 NOT {\em rd, rs}）。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}R@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
0000000 & shamt[4:0]  & src & SLLI & dest & OP-IMM \\
0000000 & shamt[4:0]  & src & SRLI & dest & OP-IMM \\
0100000 & shamt[4:0]  & src & SRAI & dest & OP-IMM \\
\end{tabular}
\end{center}

按常量移位按照I类型格式专门编码。被移位的操作数存放在{\em rs1}中，移位的数目被编码在I立即数域的低5位。
右移类型被编码在位30。SLLI（Shift Logical Right Immediate）是逻辑左移（零被移位到低位）；
SRLI（Shift Logical Left Immediate）是逻辑右移（零被移位到高位）；
而SRAI（Shift Right Arithmetic Immediate）是算数右移（原来的符号位被复制到空出来的高位）。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{U@{}R@{}O}
\\
\instbitrange{31}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[31:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
20 & 5 & 7 \\
U-immediate[31:12] & dest & LUI \\
U-immediate[31:12] & dest & AUIPC
\end{tabular}
\end{center}

LUI（加载高位立即数）被用于构建32位常量，它使用U类型格式。LUI把32位U立即数值放在目的寄存器{\em rd}中，
同时把最低的12位用零填充。

AUIPC（加高位立即数到{\tt pc}）被用于构建{\tt pc}相对地址，它使用U类型格式。
AUIPC根据U立即数形成32位偏移量（最低12位填零），把这个偏移量加到AUIPC指令的地址，然后把结果放在寄存器{\em rd}中。

\begin{commentary}

{\tt lui}和{\tt auipc}的汇编语法不代表U立即数的低12位，他们总是零。

AUIPC指令支持双指令序列，以便从{\tt pc}访问任意的偏移量，用于控制流传输和数据访问。
AUIPC与一个JALR中的12位立即数的组合可以把控制传输到任何32位{\tt pc}相对地址，
而AUIPC加上常规加载或存储指令中的12位立即数偏移量可以访问任何32位{\tt pc}相对数据地址。

通过把U立即数设置为0，可以获得当前{\tt pc}。尽管JAL+4指令也可以被用于获得本地{\tt pc}（JAL后续的指令），
但是它可能引起简单微架构中的流水线破坏，或者复杂微架构中的分支目标缓冲区结构污染。

\end{commentary}

\subsubsection*{整数寄存器 - 寄存器操作}

RV32I定义了一些R类型算数操作。所有操作都读取{\em rs1}寄存器和{\em rs2}寄存器作为源操作数，并将结果写入寄存器{\em rd}。
{\em funct7}域和{\em funct3}域制定了操作的类型。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{S@{}R@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct7} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
0000000 & src2 & src1 & ADD/SLT[U]  & dest & OP    \\
0000000 & src2 & src1 & AND/OR/XOR  & dest & OP    \\
0000000 & src2 & src1 & SLL/SRL     & dest & OP    \\
0100000 & src2 & src1 & SUB/SRA     & dest & OP    \\
\end{tabular}
\end{center}

ADD执行{\em rs1}和{\em rs2}的相加。SUB执行从{\em rs1}中减去{\em rs2}。
忽略结果的溢出，并把结果的低XLEN位写入目的寄存器{\em rd}。SLT和SLTU分别执行有符号和无符号的比较，
如果$\mbox{\em rs1} < \mbox{\em rs2}$，向{\em rd}写入1，否则写入0。
注意，如果{\em rs2}不等于零，SLTU {\em rd}, {\em x0}, {\em rs2}把{\em rd}设置为1，
否则把rd设置为0（汇编器伪指令SNEZ {\em rd, rs}）。AND、OR和XOR执行按位逻辑操作。

SLL、SLR和SRA对寄存器{\em rs1}中的值执行逻辑左移、逻辑右移、和算数右移，移位的数目保持在寄存器{\em rs2}的低5位中。

\subsubsection*{NOP 指令}
\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}S@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
0 & 0 & ADDI & 0 & OP-IMM \\
\end{tabular}
\end{center}

除了使{\tt pc}前进，以及使任何适用的性能计数器递增以外，NOP指令不改变任何架构上的可见状态。NOP被编码为ADDI {\em x0, x0, 0}。

\begin{commentary}

NOP可以被用于把代码段对齐到微架构上的高位有效地址边界，或者为内联代码的修改留出空间。
尽管有许多可能的方法来编码NOP，我们定义了一个规范的NOP编码，来允许微架构优化，
以及更具可读性的反汇编输出。其它的NOP编码形式可用于HINT指令（第2.9节~\ref{sec:rv32i-hints}）。

选用ADDI进行NOP编码是因为，这是在跨多个系统中最可能的、最少资源来执行的方法（如果解码中没有优化的话）。
特别是，指令只会读一个寄存器。并且，ADDI功能单元也更可能用于超标量设计，因为加法是最常见的操作。
特别是，地址生成（address-generation）功能单元可以使用计算基址+偏移量地址计算所需的相同硬件来执行ADDI，
而寄存器-寄存器ADD或者逻辑/移位操作都需要额外的硬件。
\end{commentary}

\section{控制转移指令}

RV32I提供两种类型的控制转移指令：无条件跳转和条件分支。RV32I中的控制转移指令{\em 没有}架构上可见的延迟槽。

如果在一次跳转或发生转移的目标上发生了一个指令访问故障异常或指令缺页故障异常，该异常会报告在目标指令上，而不是报告在跳转或分支指令上。

\subsubsection*{无条件跳转}

\vspace{-0.1in} 跳转和链接（JAL）指令使用J类型格式。J类型指令把J立即数以2字节的倍数编码一个有符号的偏移量。
偏移量是符号扩展的，加到当前跳转指令的地址上以形成跳转目标地址。跳转可以因此到达的目标范围是$\pm$\wunits{1}{MiB}。
JAL把跟在JAL之后的指令的地址（{\tt pc}+4）存储到寄存器{\em rd}中。
标准软件调用约定使用{\tt x1}作为返回地址寄存器，使用{\tt x5} 作为备选的链接寄存器。

\begin{commentary}

备选的链接寄存器支持调用millicode例程（例如，那些在压缩代码中的保存和恢复寄存器的例程），
同时保留常规的返回地址寄存器。寄存器{\tt x5}被选为备用链接寄存器，映射到标准调用约定中的一个临时值，其编码与常规链接寄存器相比只有一位不同。
\end{commentary}

一般的无条件跳转（汇编器伪指令J）被编码为{\em rd}={\tt x0}的JAL。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{W@{}E@{}W@{}R@{}R@{}O}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{21} &
\multicolumn{1}{c}{\instbit{20}} &
\instbitrange{19}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[20]} &
\multicolumn{1}{c|}{imm[10:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{1}{c|}{imm[19:12]} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
1 & 10 & \multicolumn{1}{c}{1} & 8 & 5 & 7 \\
\multicolumn{4}{c}{offset[20:1]} & dest & JAL \\
\end{tabular}
\end{center}

间接跳转指令JALR（跳转和链接寄存器）使用I类型编码。
通过把符号扩展的12位I立即数加到寄存器{\em rs1}来获得目标地址，然后把结果的最低有效位设置为零。
紧接着跳转的指令的地址（{\tt pc}+4）被写入寄存器{\em rd}。如果不需要结果，寄存器{\tt x0}也可以被用作目的寄存器。
\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
offset[11:0] & base & 0 & dest & JALR \\
\end{tabular}
\end{center}

\begin{commentary}

无条件跳转指令都使用{\tt pc}相对地址，以此支持位置无关代码。
JALR指令被定义为能够使用双指令序列跳转到32位绝对地址空间范围内的任何地方。
一条LUI指令可以首先把目标地址的高20位加载到{\em rs1}，然后JALR指令可以加上低位。
类似地，先用AUIPC再用JALR可以跳转到32位{\tt pc}相对地址范围中的任何地方。

注意JALR指令不会像条件分支指令那样，把12位立即数当作2字节的倍数对待。这回避了硬件中出现的另一种立即数格式。
实际上，大多数JALR的使用，要么有一个零立即数，要么是与LUI或AUIPC搭配成对，所以有一点范围减少是无关紧要的。

在计算JALR目标地址时清理最低有效的位，既稍微简化了硬件，又允许函数指针的低位被用于存储辅助信息。
尽管这种情况中，会有一些潜在的错误检查的轻微丢失，但是实际上，跳转到一个不正确的指令地址通常将很快引发一个异常。

当以{\em rs1}$=${\tt x0}作为基地址使用时，JALR可以被用于实现地址空间中从任何地方到最低\wunits{2}{KiB}
或最高\wunits{2}{KiB}地址区域的单一指令子例程调用，这可以被用于实现对小型运行时库的快速调用。
或者，ABI可以专用于通用目的寄存器，以指向地址空间中任何其它地方的一个库。
\end{commentary}

如果目标地址没有对齐到IALIGN位边界，JAL和JALR指令将产生一个指令地址未对齐（ instruction-address-misaligned）异常。

\begin{commentary}

指令地址未对齐异常不会发生在IALIGN＝16的机器上，例如那些支持压缩指令集扩展（C）的机器。
\end{commentary}

返回地址预测栈是高性能取指单元的一个常见特征，但是需要精确地探测用于过程调用和有效返回、即将生效的指令。
对于RISC-V，有关指令用途的提示，是通过使用的寄存器号码被隐式地编码的。
只有当{\em rd} ＝ {\tt x1}/{\tt x5}时，JAL指令才应当把返回地址推入到返回地址栈（RAS）上。
JALR指令应当压入/弹出一个RAS的所有情形如表~\ref{rashints}所示。

\begin{table}[hbt]
\centering
\begin{tabular}{|c|c|c|l|}
  \hline
  \textit{rd} is \texttt{x1}/\texttt{x5}
      & \textit{rs1} is \texttt{x1}/\texttt{x5}
            & \textit{rd}$=$\textit{rs1} & RAS action \\
  \hline
  否  & 否  & --  & 无 \\
  否  & 是 & --  & 弹出 \\
  是 & 否  & --  & 压入 \\
  是 & 是 & 否  & 弹出，然后压入 \\
  是 & 是 & 是 & 压入 \\
   \hline
\end{tabular}
\caption{在JALR指令的寄存器操作数中编码的返回地址栈预测提示。}
\label{rashints}
\end{table}

\begin{commentary}
  
一些其它的ISA把显式的提示位添加到了它们的间接跳转指令上，来指导返回地址栈的操作。
我们使用绑定寄存器号码的隐式提示和调用约定，以减少用于这些提示的编码空间。

当两个不同的链接寄存器（{\tt x1}和{\tt x5}）被给定为{\em rs1}和{\em rd}时，
接下来RAS会被同时弹出和推入，以支持协程。
如果{\em rs1}和{\em rd}是相同的链接寄存器（{\tt x1} 或者 {\tt x5}），
RAS只是为使能序列中宏操作融合（macro-op fusion）而被推入： \\
% \linebreak
{\tt lui ra, imm20; jalr ra, imm12(ra)} \ 和 \ 
{\tt auipc ra, imm20; jalr ra, imm12(ra)}
\end{commentary}

\subsubsection*{条件分支}

所有的分支指令使用B类型指令格式。12位B立即数以2字节的倍数编码符号偏移量。
偏移量是符号扩展的，加到分支指令的地址上以给出目标地址。条件分支的范围是$\pm$\wunits{4}{KiB}。

\vspace{-0.2in}
\begin{center}
\begin{tabular}{W@{}R@{}F@{}F@{}R@{}R@{}F@{}S}
\\
\multicolumn{1}{c}{\instbit{31}} &
\instbitrange{30}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{8} &
\multicolumn{1}{c}{\instbit{7}} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[12]} &
\multicolumn{1}{c|}{imm[10:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:1]} &
\multicolumn{1}{c|}{imm[11]} &
\multicolumn{1}{c|}{opcode} \\
\hline
1 & 6 & 5 & 5 & 3 & 4 & 1 & 7 \\
\multicolumn{2}{c}{offset[12$\vert$10:5]} & src2 & src1 & BEQ/BNE & \multicolumn{2}{c}{offset[11$\vert$4:1]} & BRANCH \\
\multicolumn{2}{c}{offset[12$\vert$10:5]} & src2 & src1 & BLT[U] & \multicolumn{2}{c}{offset[11$\vert$4:1]} & BRANCH \\
\multicolumn{2}{c}{offset[12$\vert$10:5]} & src2 & src1 & BGE[U]  & \multicolumn{2}{c}{offset[11$\vert$4:1]} & BRANCH \\
\end{tabular}
\end{center}

分支指令对两个寄存器进行比较。BEQ和BNE分别在寄存器{\em rs1}和{\em rs2}相等或不等时采取分支。
BLT和BLTU分别使用有符号和无符号的比较，如果{\em rs1}小于{\em rs2}则采取分支。
BGE和BGEU分别使用有符号和无符号的比较，如果rs1大于或等于rs2则采取分支。
注意，BGT、BGTU、BLE和BLEU可以分别通过反转BLT、BLTU、BGE和BGEU的操作数来合成。

\begin{commentary}

可以用一条BLTU指令检查有符号的数组边界，因为任意负数索引都将比任意非负数边界要大。
\end{commentary}

软件应当按这样的原则来优化编写：按顺序执行的代码路径是占大部分的常见路径，
而顺序外的代码路径被采取的频率较低。软件也应当假定，向后的分支将被预测采取，而向前的分支被预测不采取，
至少在它们第一次被遇到时如此。动态预测应当快速地学习任何可预测的分支行为。

不像其它的一些架构，对于无条件分支，应当总是使用跳转指令（{\em rd}={\tt x0}的JAL），
而不是使用一个条件总是真的条件分支指令。
RISC-V的跳转也是{\tt pc}相对的，并支持比分支更宽的偏移量范围，而且将不会污染条件分支预测表。

\begin{commentary} 

条件分支被设计为包含两个寄存器之间的算数比较操作（PA-RISC、Xtensa和MIPS R6中也是这样做的），
而不是使用条件代码（x86、ARM、SPARC、PowerPC），或者只用一个寄存器和零比较（Alpha、MIPS），
又或是只比较两个寄存器是否相等（MIPS）。
这个设计的动机是观察到：比较与分支的组合指令适合于常规流水线，避免了额外的条件代码状态或者临时寄存器的使用，
并减少了静态代码的尺寸和动态指令获取的流量。
另一个考虑点是，与零比较需要非平凡的电路延迟（特别是在高级处理中运行流程到达静态逻辑后），
并因此与算数量级的比较几乎同样代价高昂。融合的比较与分支指令的另一个优势是，
分支可以在前端指令流中被更早地观察到，并因此能够被更早地预测。
在基于相同的条件代码可以采取多个分支的情况中，使用条件代码的设计或许有优势，但是我们相信这种情况是相对稀少的。

我们考虑过，但是没有在指令编码中包含静态分支提示。这些虽然可以减少动态预测器的压力，
但是需要更多指令编码空间和软件画像来达到最佳结果，并且如果产品的运行没有匹配画像（profiling）运行的话，会导致性能变差。

我们考虑过，但是没有包含条件移动或谓词指令，它们可以有效地替换不可预测的短向前分支（short forward branches）。
条件移动是二者中较简单的，但是难以和条件代码一起使用，因为那会引起异常（内存访问和浮点操作）。
谓词会给系统添加额外的标志，添加额外的指令来设置和清除标志，以及在每个指令上增加额外的编码负担。
条件移动和谓词指令都会增加乱序微架构的复杂度，因为如果谓词为假，则需要把目的架构寄存器的原始值复制到重命名后的目的物理寄存器，
因此会添加隐含的第三个源操作数。此外，静态编译时间决定使用谓词而不是分支，可以导致没有包含在编译器训练集中的输入的性能降低，
尤其是考虑到不可预测的分支是稀少的，而且随着分支预测技术的改进会而变得更加稀少。

我们注意到，现存的各种微架构技术会把不可预测的短向前分支转化为内部谓词代码，
以避免分支误预测时冲刷流水线的开销~\cite{heil-tr1996,Klauser-1998,Kim-micro2005}，
并且已经在商业处理器中被实现~\cite{ibmpower7}。最简单的技术只是通过只冲刷分支阴影（branch shadown）中的指令，
而不是整个取指流水线，或者通过使用宽指令取指或空闲指令取指槽从两端获取指令，从而减少了从误预测短向前分支恢复的代价。
用于乱序核心中的更加复杂的技术是在分支阴影中的指令上添加内部谓词，内部谓词的值由分支指令写入，
这允许分支和随后的指令相比于其他代码被推测执行和乱序执行，而与其它代码的执行顺序不一致~\cite{ibmpower7}。
\end{commentary}

如果目标地址没有对齐到IALIGN位边界，并且分支条件评估为真，那么条件分支指令将生成一个指令地址未对齐异常。
如果分支条件评估为假，那么指令地址未对齐异常将不会产生。

\begin{commentary}

指令地址未对齐异常不会发生在支持16位对齐指令扩展（例如，压缩指令集扩展C）的机器上。
\end{commentary}

\section{加载和存储指令}
\label{sec:rv32:ldst}

RV32I是一个“加载-存储”架构，只有加载和存储指令访问内存，而算数指令只操作CPU寄存器。
RV32I提供一个32位的地址空间，按字节编址。
EEI将定义该地址空间的哪一部分是哪个指令可以合法访问的（例如，一些地址可能是只读的，或者只支持按字访问）。
以{\tt x0}为目的寄存器的加载操作必定会引发某些异常，并引起其它的副作用，即使所加载的值被丢弃。

EEI将定义内存系统是否是小字节序或大字节序的。在RISC-V中，字节序是按字节编址的不变量。

\begin{commentary}
  
  在字节序是按字节编址不变量的系统中，有如下的属性：如果一个字节以某个字节序被存储到内存的某个地址，
  那么从那个地址开始以任何字节序的一个字节大小的加载操作都将返回被存储的值。

  在一个小字节序的配置中，对于多字节的存储，在最低内存字节地址处写入寄存器字节的最低有效位，
  然后按有效位的升序写入其它的寄存器字节。加载类似，把较小有效位的内存字节地址的内容传输到较低有效位的寄存器字节。

  在一个大字节序的配置中，对于多字节的存储，在最低内存字节地址处写入寄存器字节的最高有效位，然后按有效位的降序写入其它的寄存器字节。
  加载类似，把较大有效位的内存字节地址的内容传输到较低有效位的寄存器字节。

\end{commentary}

\vspace{-0.4in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:0]} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
offset[11:0] & base & width & dest & LOAD \\
\end{tabular}
\end{center}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{O@{}R@{}R@{}F@{}R@{}O}
\\
\instbitrange{31}{25} &
\instbitrange{24}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{imm[11:5]} &
\multicolumn{1}{c|}{rs2} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{imm[4:0]} &
\multicolumn{1}{c|}{opcode} \\
\hline
7 & 5 & 5 & 3 & 5 & 7 \\
offset[11:5] & src & base & width & offset[4:0] & STORE \\
\end{tabular}
\end{center}

加载和存储指令在寄存器和内存之间传输一个值。加载指令被编码为I类型格式，存储指令则是S类型。
通过把寄存器{\em rs1}加到符号扩展的12位偏移量，可以获得有效地址。加载指令从内存复制一个值到寄存器{\em rd}。
存储指令把寄存器{\em rs2}中的值复制到内存。

LW指令从内存加载一个32位的值到{\em rd}。LH先从内存加载一个16位的值，然后在存储到{\em rd}中之前，把它符号扩展到32位。
LHU先从内存加载一个16位的值，然后，在存储到{\em rd}中之前，把它用零扩展到32位。
LB和LBU被类似地定义于8位的值。SW、SH和SB指令从寄存器{\em rs2}的低位将32位、16位和8位的值存储到内存。

不管EEI如何，有效位地址自然对齐的加载和存储不应当引发地址未对齐的异常。对于有效位地址没有自然对齐到被引用的数据类型的情况
（即，有效地址不能被以字节为单位的访问大小整除），其行为取决于EEI。

EEI也可以完全支持未对齐的加载和存储，使得运行在执行环境内部的软件将永不会经历包含的或者致命的
（译者注：见1.6节提到的陷入类型）地址未对齐陷入。在这种情况中，未对齐的加载和存储可以在硬件中被处理，
或者通过一个不可见的陷入进入执行环境，或者根据具体地址，可能是硬件和不可见陷入的组合。

EEI可以不保证未对齐的加载和存储被不可见地处理掉。在这种情况中，没有自然对齐的加载和存储或者可以成功地完成执行，或者可以引发一个异常。所引发的异常可以是一个地址未对齐异常，也可以是一个访问故障异常。对于除了未对齐外都能够完成的内存访问，如果不能模拟未对齐访问（例如，如果对内存区域的访问有副作用），那么可以引发一个访问故障异常而不是一个地址未对齐异常。当EEI不保证隐式地处理未对齐的加载和存储时，EEI必须定义由地址未对齐引起的异常是否导致被包含的陷入（允许运行在执行环境中的软件来处理该陷入），或者导致致命的陷入（终止执行）。


\begin{commentary}

  当移植遗留代码时，偶尔需要未对齐的访问；在使用某些形式的packed-SIMD扩展（译者注：打包的SIMD扩展指令，即P扩展）、或者处理外部打包的数据结构时，这些未对齐的访问对应用程序的性能会有帮助。对于是否允许EEI通过常规的加载和存储指令来选择支持未对齐的访问，我们的基本原则是，是否能够简化因额外处理未对齐而引入的硬件电路设计的复杂性。一个选择是，在基础ISA中将不允许未对齐的访问，然后为未对齐访问提供一些单独的ISA支持：或者是用一些特殊指令来帮助软件处理未对齐访问，或者是用未对齐访问的新的硬件编址模式。特殊指令是难以使用的，会让ISA复杂化，并通常增加了新的处理器状态（例如，SPARC VIS对齐地址偏移量寄存器），或是让现有处理器状态的访问复杂化（例如，MIPS LWL/LWR部分寄存器写操作）。此外，对于面向循环的packed-SIMD代码，当操作数未对齐时，会迫使软件根据操作数的对齐方式提供多种形式的循环，这使代码生成复杂化，并增加了循环启动的负担。新的未对齐硬件编址模式或者会占据相当多的指令编码空间，或者需要非常简化的编址模式（例如，只有寄存器间接寻址模式）。
\end{commentary}

即使是当未对齐的加载和存储成功完成时，根据实现不同，这些访问也可能运行得极度缓慢（例如，当通过一个不可见的陷入实现时）。此外，自然对齐的加载和存储会被保证原子执行，但未对齐的加载和存储却可能不会，并因此需要额外的同步来保证原子性。

% Even when misaligned loads and stores complete successfully, these
% accesses might run extremely slowly depending on the implementation
% (e.g., when implemented via an invisible trap).  Furthermore, whereas
% naturally aligned loads and stores are guaranteed to execute
% atomically, misaligned loads and stores might not, and hence
% require additional synchronization to ensure atomicity.

\begin{commentary}

  我们没有强制要求未对齐访问的原子性，所以执行环境可以使用一种不可见的机器陷入和一个软件处理程序来处理部分或所有的未对齐访问。
  如果提供了未对齐硬件支持，软件利用它简单地使用常规加载和存储指令就可以。然后，硬件可以根据运行时地址是否对齐自动优化访问。
\end{commentary}

\pagebreak

\section{内存排序指令}
\label{sec:fence}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{F@{}IIIIIIIIF@{}F@{}F@{}S}
\\
\instbitrange{31}{28} &
\multicolumn{1}{c}{\instbit{27}} &
\multicolumn{1}{c}{\instbit{26}} &
\multicolumn{1}{c}{\instbit{25}} &
\multicolumn{1}{c}{\instbit{24}} &
\multicolumn{1}{c}{\instbit{23}} &
\multicolumn{1}{c}{\instbit{22}} &
\multicolumn{1}{c}{\instbit{21}} &
\multicolumn{1}{c}{\instbit{20}} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{fm} &
\multicolumn{1}{c|}{PI} &
\multicolumn{1}{c|}{PO} &
\multicolumn{1}{c|}{PR} &
\multicolumn{1}{c|}{PW} &
\multicolumn{1}{|c|}{SI} &
\multicolumn{1}{c|}{SO} &
\multicolumn{1}{c|}{SR} &
\multicolumn{1}{c|}{SW} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
4 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 5 & 3 & 5 & 7 \\
FM & \multicolumn{4}{c}{前驱} & \multicolumn{4}{c}{后继} & 0 & FENCE & 0 & MISC-MEM \\
\end{tabular}
\end{center}

FENCE指令被用于为其它RISC-V硬件线程和外部设备或协处理器所看到的设备I/O和内存访问进行排序。
设备输入（I）、设备输出（O）、内存读（R）和内存写（W）的任意组合可以与其他同样这些的任意组合进行排序。
可以非正式地认为，没有其它的RISC-V硬件线程或外部设备可以在FENCE之前的{\em 前驱（predecessor）}集合中的任何操作之前，
观察到FENCE之后的{\em 后继（successor）}集合中的任何操作。第17章~\ref{ch:memorymodel}提供了RISC-V内存一致性模型的一个精确的描述。
% The FENCE instruction is used to order device I/O and
% memory accesses as viewed by other RISC-V harts and external devices
% or coprocessors.  Any combination of device input (I), device output
% (O), memory reads (R), and memory writes (W) may be ordered with
% respect to any combination of the same.  Informally, no other RISC-V
% hart or external device can observe any operation in the {\em
%   successor} set following a FENCE before any operation in the {\em
%   predecessor} set preceding the FENCE.
% Chapter~\ref{ch:memorymodel} provides a precise description of the
% RISC-V memory consistency model.

如同所观察到的对那些外部设备发起的内存读写进行排序，FENCE指令也对硬件线程发起的内存读和内存写进行排序。然而，FENCE不对外部设备使用任何其它信号机制发起的观察事件进行排序。
% The FENCE instruction also orders memory reads and writes made by the
% hart as observed by memory reads and writes made by an external
% device.  However, FENCE does not order observations of events made by
% an external device using any other signaling mechanism.

\begin{commentary}

  一个设备可能通过某些外部通信机制（例如，一个为中断控制器驱动中断信号的内存映射控制寄存器）观察到对一个内存位置的访问。这个通信是在FENCE排序机制的视野之外的，因此，FENCE指令不能保证中断信号变化何时能对中断控制器可见。特定的设备可以提供额外的排序保证以减少软件负载，但属于RISC-V内存模型的范畴之外的话题。

一个设备可能通过某些外部通信机制（例如，一个为中断控制器驱动中断信号的内存映射控制寄存器）观察到对一个内存位置的访问。
这个通信是在FENCE排序机制的视野之外的，因此，FENCE指令不能提供保证，中断信号的变化何时能对中断控制器可见。
特定的设备可以提供额外的排序保证以减小软件负载，但是那些机制属于RISC-V内存模型的范畴之外了。
% A device might observe an access to a memory location via some
% external communication mechanism, e.g., a memory-mapped control
% register that drives an interrupt signal to an interrupt controller.
% This communication is outside the scope of the FENCE ordering
% mechanism and hence the FENCE instruction can provide no guarantee on
% when a change in the interrupt signal is visible to the interrupt
% controller.  Specific devices might provide additional ordering
% guarantees to reduce software overhead but those are outside the scope
% of the RISC-V memory model.
\end{commentary}

EEI将定义什么样的I/O操作是允许的，特别是当被加载和存储指令访问时，分别有哪些内存地址将被视为设备输入和设备输出操作、而不是内存读取和写入操作，并以此排序。例如，内存映射I/O设备通常被未缓存的加载和存储访问，这些访问使用I和O位而不是R和W位进行排序。指令集扩展也可以在FENCE中规定同样使用I和O位排序的新的I/O指令。

% The EEI will define what I/O operations are possible, and in
% particular, which memory addresses when accessed by load and store instructions will be treated and
% ordered as device input and device output operations respectively
% rather than memory reads and writes.  For example, memory-mapped I/O
% devices will typically be accessed with uncached loads and stores that
% are ordered using the I and O bits rather than the R and W bits.
% Instruction-set extensions might also describe new I/O
% instructions that will also be ordered using the I and O bits in a
% FENCE.

\begin{table}[htp]
\begin{small}
\begin{center}
\begin{tabular}{|c|c|l|}
\hline
{\em fm} 域 & 助记符 & 含义 \\
\hline
0000 & \em 无 & 一般的屏障 \\
\hline
\multirow{2}{*}{1000} & \multirow{2}{*}{TSO} & 带有FENCE RW, RW：排除“写到读”的次序 \\
                      &                      & 其它的：\em 保留供未来使用。 \\
\hline
\multicolumn{2}{|c|}{\em 其他} & \em 保留供未来使用。 \\
\hline
\end{tabular}
\end{center}
\end{small}
\caption{屏障模式编码}
\label{fm}
\end{table}

屏障模式域{\em fm}定义了FENCE的语义。一个{\em fm}=0000的FENCE把它的前驱集合中的所有内存操作，
排在它的后继集合的所有内存操作之前。
% The fence mode field {\em fm} defines the semantics of the FENCE.  A
% FENCE with {\em fm}=0000 orders all memory operations in its
% predecessor set before all memory operations in its successor set. 

FENCE.TSO指令被编码为{\em fm}=1000、{\em 前驱}RW、以及{\em 后继}＝RW的FENCE指令。
FENCE.TSO把它前驱集合中的所有加载操作排在它后继集合中的所有内存操作之前，
并把它前驱集合中的所有存储操作排在它后继集合中的所有存储操作之前。
这使得FENCE.TSO的前驱集合中的非AMO存储操作与它的后继集合中的非AMO加载操作不再有序。
% The FENCE.TSO instruction is encoded as a FENCE instruction
% with {\em fm}=1000, {\em predecessor}=RW, and {\em successor}=RW.
% FENCE.TSO orders all load
% operations in its predecessor set before all memory operations in its
% successor set, and all store operations in its predecessor set before
% all store operations in its successor set.  This leaves non-AMO store
% operations in the FENCE.TSO's predecessor set unordered with non-AMO
% loads in its successor set.

\begin{commentary}
  因为\mbox{FENCE RW,RW}所施加的排序是FENCE.TSO所施加排序的一个超集，
  所以忽略{\em fm}域并把FENCE.TSO作为\mbox{FENCE RW,RW}实现是正确的。
  % Because \mbox{FENCE RW,RW} imposes a superset of the orderings that
  % FENCE.TSO imposes, it is correct to ignore the {\em fm} field and
  % implement FENCE.TSO as \mbox{FENCE RW,RW}.
\end{commentary}

FENCE指令中的未使用的域——{\em rs1}和{\em rd}——被保留用于未来扩展中的更细粒度的屏障。
为了向前兼容，基础实现应当忽略这些域，而标准软件应当把这些域置为零。
同样地，表~\ref{fm}中的许多{\em fm}和前驱/后继集合设置也被保留供将来使用。
基础实现应当把所有这些保留的配置视为普通的{\em fm}＝0000的屏障，而标准软件应当只使用非保留的配置。
% The unused fields in the FENCE instructions---{\em rs1} and {\em rd}---are
% reserved for finer-grain fences in future extensions.  For forward
% compatibility, base implementations shall ignore these fields, and standard
% software shall zero these fields.  Likewise, many {\em fm} and
% predecessor/successor set settings in Table~\ref{fm} are also reserved
% for future use.  Base implementations shall treat all such reserved
% configurations as normal fences with {\em fm}=0000, and standard
% software shall use only non-reserved configurations.

\begin{commentary}
我们选择了一个宽松的内存模型以允许从简单的机器实现和可能的未来协处理器或加速器扩展获得高性能。
我们从内存R/W排序中分离了I/O排序以避免在一个设备驱动硬件线程中进行不必要的序列化，
而且也支持备用的非内存路径来控制额外增加的协处理器或I/O设备。此外，简单的实现还可以忽略{\em 前驱}和{\em 后继}的域，
而总是在所有的操作上执行保守的屏障。
% We chose a relaxed memory model to allow high performance from simple
% machine implementations and from likely future
% coprocessor or accelerator extensions.  We separate out I/O ordering
% from memory R/W ordering to avoid unnecessary serialization within a
% device-driver hart and also to support alternative non-memory paths
% to control added coprocessors or I/O devices.  Simple implementations
% may additionally ignore the {\em predecessor} and {\em successor}
% fields and always execute a conservative fence on all operations.
\end{commentary}

\section{环境调用和断点}

SYSTEM指令被用于访问那些可能需要访问特权的系统功能，并且使用I类型指令格式进行编码。
这些指令可以被划分为两个主要的类别：那些原子性的“读-修改-写”控制和状态寄存器（CSR）相关指令，和所有其它潜在的特权指令。
CSR指令在第~\ref{csrinsts}章描述，而基础非特权指令在接下来的小节中描述。
% SYSTEM instructions are used to access system functionality that might
% require privileged access and are encoded using the I-type instruction
% format.  These can be divided into two main classes: those that
% atomically read-modify-write control and status registers (CSRs), and
% all other potentially privileged instructions. CSR instructions are
% described in Chapter~\ref{csrinsts}, and the base unprivileged instructions
% are described in the following section.

\begin{commentary}

  在简单的实现中，SYSTEM指令被定义为允许更简单的实现总是陷入到一个单独的软件陷入处理程序。
更复杂的实现可能在硬件中执行更多的各系统指令。
% The SYSTEM instructions are defined to allow simpler implementations
% to always trap to a single software trap handler.  More sophisticated
% implementations might execute more of each system instruction in
% hardware.
\end{commentary}

\vspace{-0.2in}
\begin{center}
\begin{tabular}{M@{}R@{}F@{}R@{}S}
\\
\instbitrange{31}{20} &
\instbitrange{19}{15} &
\instbitrange{14}{12} &
\instbitrange{11}{7} &
\instbitrange{6}{0} \\
\hline
\multicolumn{1}{|c|}{funct12} &
\multicolumn{1}{c|}{rs1} &
\multicolumn{1}{c|}{funct3} &
\multicolumn{1}{c|}{rd} &
\multicolumn{1}{c|}{opcode} \\
\hline
12 & 5 & 3 & 5 & 7 \\
ECALL   & 0 & PRIV & 0 & SYSTEM \\
EBREAK  & 0 & PRIV & 0 & SYSTEM \\
\end{tabular}
\end{center}

这两个指令对支持的执行环境引发了一个精确的请求陷入。
% These two instructions cause a precise requested trap to the
% supporting execution environment.

ECALL指令被用于向执行环境发起一个服务请求。EEI将定义服务请求参数传递的方式，
但是通常这些参数将处于整数寄存器文件中已定义的位置。
% The ECALL instruction is used to make a service request to the
% execution environment.  The EEI will define how parameters for the
% service request are passed, but usually these will be in defined
% locations in the integer register file.

EBREAK指令被用于将控制返回到调试环境。
% The EBREAK instruction is used to return control to a debugging
% environment.

\begin{commentary}
ECALL和EBREAK之前被命名为SCALL和SBREAK。这些指令有相同的功能和编码，但是被重命名了，
是为了反映它们可以更一般化地使用，而不只是调用一个监管器级别的操作系统或者调试器。
% ECALL and EBREAK were previously named SCALL and SBREAK.  The
% instructions have the same functionality and encoding, but were
% renamed to reflect that they can be used more generally than to call a
% supervisor-level operating system or debugger.
\end{commentary}

\begin{commentary}
  EBREAK被主要设计为供调试器使用的，以引发执行停止和返回到调试器中。
  EBREAK也被标准gcc编译器用来标记可能不会被执行的代码路径。
  % EBREAK was primarily designed to be used by a debugger to cause
  % execution to stop and fall back into the debugger. EBREAK is also
  % used by the standard gcc compiler to mark code paths that should not
  % be executed.

  EBREAK的另一个用处是支持“半宿主”，即，包含调试器的执行环境可以通过围绕EBREAK指令构建一套备用系统调用接口来提供服务。
  因为RISC-V基础ISA没有提供更多的（多于一个的）EBREAK指令，
  RISC-V半宿主使用一个特殊的指令序列来将半宿主EBREAK与调试器插入的EBREAK进行区分。
  % Another use of EBREAK is to support ``semihosting'', where the
  % execution environment includes a debugger that can provide services
  % over an alternate system call interface built around the EBREAK
  % instruction.  Because the RISC-V base ISAs do not provide more than
  % one EBREAK instruction, RISC-V semihosting uses a special sequence of
  % instructions to distinguish a semihosting EBREAK from a debugger
  % inserted EBREAK.
\begin{verbatim}
    slli x0, x0, 0x1f   # 入口 NOP
    ebreak              # 中断到调试器
    srai x0, x0, 7      # NOP编码编号为7的半宿主调用
\end{verbatim}
  注意这三个指令都必须是32位宽的指令，也就是说，它们必须不能出现在第~\ref{compressed}章里描述的压缩16位指令之中。
  %  Note that these three instructions must be 32-bit-wide instructions,
  %  i.e., they mustn't be among the compressed 16-bit instructions
  %  described in Chapter~\ref{compressed}.
  
   移位NOP指令仍然被认为可以用作HINT
  %  The shift NOP instructions are still considered available for use as
  %  HINTs.

   半宿主是一种服务调用的形式，它将更自然地使用现有ABI被编码为ECALL，但是这将要求调试器有能力拦截ECALL，
   那是对调试标准的一个较新的补充。我们试图改为使用带有标准ABI的ECALL，这种情况中，半宿主可以与现有标准分享服务ABI。
  %  Semihosting is a form of service call and would be more naturally
  %  encoded as an ECALL using an existing ABI, but this would require
  %  the debugger to be able to intercept ECALLs, which is a newer
  %  addition to the debug standard.  We intend to move over to using
  %  ECALLs with a standard ABI, in which case, semihosting can share a
  %  service ABI with an existing standard.
  
   我们注意到，ARM处理器在较新的设计中，对于半宿主调用，也已经转为使用了SVC而不再是BKPT。
  %  We note that ARM processors have also moved to using SVC instead of
  %  BKPT for semihosting calls in newer designs.
\end{commentary}

\section{“提示”指令}
\label{sec:rv32i-hints}

RV32I保留了大量的编码空间用于HINT指令，这些通常被用于与微架构进行性能提示的交互。
像NOP指令，除了提升{\tt pc}和任何适用的性能计数器，HINT不改变任何架构上的可视状态。实现中总是被允许忽略已编码的提示。
% RV32I reserves a large encoding space for HINT instructions, which are
% usually used to communicate performance hints to the
% microarchitecture.
% Like the NOP instruction, HINTs do not change any architecturally visible
% state, except for advancing the {\tt pc} and any applicable performance
% counters.
% Implementations are always allowed to ignore the encoded hints.

大多数RV32I HINT被编码为{\em rd}={\tt x0}的整数运算指令。
其余RV32I HINT被编码为没有前驱集和后继集且{\em fm}＝0的FENCE指令。
% Most RV32I HINTs are encoded as integer computational instructions with
% {\em rd}={\tt x0}.
% The other RV32I HINTs are encoded as FENCE instructions with a null
% predecessor or successor set and with {\em fm}=0.

\begin{commentary}
选择这样的HINT编码是为了简单的实现可以完全忽略HINT，而把HINT作为一个常规的、但是恰好不改变架构状态的指令。
例如，如果目的寄存器是{\tt x0}，那么ADD就是一个HINT；五位的{\em rs1}和{\em rs2}域编码了HINT的参数。
然而，简单的实现中可以简单地把HINT执行为把{\em rs1}加{\em rs2}写入{\tt x0}的ADD指令，这种没有架构上可见的影响。
% These HINT encodings have been chosen so that simple implementations can ignore
% HINTs altogether, and instead execute a HINT as a regular
% instruction that happens not to mutate the architectural state.  For example, ADD is
% a HINT if the destination register is {\tt x0}; the five-bit {\em rs1} and {\em
% rs2} fields encode arguments to the HINT.  However, a simple implementation can
% simply execute the HINT as an ADD of {\em rs1} and {\em rs2} that writes {\tt
% x0}, which has no architecturally visible effect.

作为另一个例子，一个{\em pred}域为零且{\em fm} 域为零的FENCE指令是一个HINT；
{\em succ}域， {\em rs1}域， and {\em rd}域编码了HINT的参数。
一个简单的实现可以把HINT作为一个FENCE简单地执行，即，在任何被编码在{\em succ}域中的后续内存访问之前，
对先前内存访问的空集进行排序。由于前驱集和后继集的交集为空，该指令不会施加内存排序，因此它没有架构可见的影响。
% As another example, a FENCE instruction with a zero {\em pred} field and
% a zero {\em fm} field is a HINT; the {\em succ}, {\em rs1}, and {\em rd}
% fields encode the arguments to the HINT.
% A simple implementation can simply execute the HINT as a FENCE that orders the
% null set of prior memory accesses before whichever subsequent memory accesses
% are encoded in the {\em succ} field.
% Since the intersection of the predecessor and successor sets is null, the
% instruction imposes no memory orderings, and so it has no architecturally
% visible effect.
\end{commentary}

表~\ref{tab:rv32i-hints}列出了所有的RV32I HINT代码点。91\%的HINT空间被保留用于标准HINT。
剩余的HINT空间被指定用于自定义的HINT：在这个子空间中，将永远不会定义标准HINT。
% Table~\ref{tab:rv32i-hints} lists all RV32I HINT code points.  91\% of the HINT
% space is reserved for standard HINTs.  The
% remainder of the HINT space is designated for custom HINTs: no standard HINTs
% will ever be defined in this subspace.

\begin{commentary}
我们预计标准的提示最终会包含内存系统空间和时间的局部性提示、分支预测提示、线程调度提示、安全性标签、和用于模拟/仿真的仪器标志。
% We anticipate
% standard hints to eventually include memory-system spatial and
% temporal locality hints, branch prediction hints, thread-scheduling
% hints, security tags, and instrumentation flags for
% simulation/emulation.
\end{commentary}

\begin{table}[hbt]
\centering
\begin{tabular}{|l|l|c|l|}
  \hline
  指令                   & 约束                                        & 代码点                       & 目的\\ \hline \hline
  LUI                   & {\em rd}={\tt x0}                           & $2^{20}$                    & \multirow{10}{*}{\em 保留供未来标准使用} \\ \cline{1-3}
  AUIPC                 & {\em rd}={\tt x0}                           & $2^{20}$                    & \\ \cline{1-3}
  \multirow{2}{*}{ADDI} & {\em rd}={\tt x0}, 并且要么                  & \multirow{2}{*}{$2^{17}-1$} & \\
                        & {\em rs1}$\neq${\tt x0} 要么 {\em imm}$\neq$0 &                             & \\ \cline{1-3}
  ANDI                  & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  ORI                   & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  XORI                  & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  ADD                   & {\em rd}={\tt x0}, {\em rs1}$\neq${\tt x0}  & $2^{10}-32$                 & \\ \cline{1-3}
  \multirow{2}{*}{ADD}  & {\em rd}={\tt x0}, {\em rs1}={\tt x0},      & \multirow{2}{*}{$28$}       & \\
                        & {\em rs2}$\neq${\tt x2}--{\tt x5}           &                             & \\ \hline
  \multirow{4}{*}{ADD}  & \multirow{4}{*}{\shortstack[l]{{\em rd}={\tt x0}, {\em rs1}={\tt x0}, \\{\em rs2}={\tt x2}--{\tt x5}}}
                                                                      & \multirow{4}{*}{$4$}        & ({\em rs2}={\tt x2}) NTL.P1 \\
                        &                                             &                             & ({\em rs2}={\tt x3}) NTL.PALL \\
                        &                                             &                             & ({\em rs2}={\tt x4}) NTL.S1 \\
                        &                                             &                             & ({\em rs2}={\tt x5}) NTL.ALL \\ \hline
  SUB                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \multirow{17}{*}{\em 保留供未来标准使用} \\ \cline{1-3}
  AND                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  OR                    & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  XOR                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SLL                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRL                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRA                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  \multirow{3}{*}{FENCE}& {\em rd}={\tt x0}, {\em rs1}$\neq${\tt x0}, & \multirow{3}{*}{$2^{10}-63$}& \\
                        & {\em fm}=0,且 {\em pred}=0 或者 {\em succ}=0                 &                             & \\ \cline{1-3} 
                   %     &                &                             & \\ 
  \multirow{3}{*}{FENCE}& {\em rd}$\neq${\tt x0}, {\em rs1}={\tt x0}, & \multirow{3}{*}{$2^{10}-63$}& \\
                        & {\em fm}=0, 且{\em pred}=0 或者 {\em succ}=0            &                             & \\ \cline{1-3}
              %          &               &                             & \\ 
  \multirow{2}{*}{FENCE}& {\em rd}={\em rs1}={\tt x0}, {\em fm}=0,    & \multirow{2}{*}{15}         & \\
                        & {\em pred}=0, {\em succ}$\neq$0             &                             & \\ \cline{1-3}
  \multirow{2}{*}{FENCE}& {\em rd}={\em rs1}={\tt x0}, {\em fm}=0,    & \multirow{2}{*}{15}         & \\
                        & {\em pred}$\neq$W, {\em succ}=0             &                             & \\ \hline
  \multirow{2}{*}{FENCE}& {\em rd}={\em rs1}={\tt x0}, {\em fm}=0,    & \multirow{2}{*}{1}          & \multirow{2}{*}{暂停} \\
                        & {\em pred}=W, {\em succ}=0                  &                             & \\ \hline \hline
  SLTI                  & {\em rd}={\tt x0}                           & $2^{17}$                    & \multirow{7}{*}{\em 指定供自定义使用} \\ \cline{1-3}
  SLTIU                 & {\em rd}={\tt x0}                           & $2^{17}$                    & \\ \cline{1-3}
  SLLI                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRLI                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SRAI                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SLT                   & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \cline{1-3}
  SLTU                  & {\em rd}={\tt x0}                           & $2^{10}$                    & \\ \hline
\end{tabular}
\caption{RV32I 提示指令。}
\label{tab:rv32i-hints}
\end{table}

