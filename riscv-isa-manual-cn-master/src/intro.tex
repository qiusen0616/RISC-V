\chapter{介绍}
RISC-V（发音“risk-five”）是一个新的指令集架构（ISA），它原本是为了支持计算机架构的研究和教育而设计的，
但是我们现在希望它也将成为一种用于工业实现的、标准的、免费和开放的架构。
我们在定义RISC-V方面的目标包括：

\vspace{-0.1in}
\begin{itemize}
\parskip 0pt
\itemsep 1pt
\item 一个完全{\em 开放}的ISA，学术界和工业界可以免费获得它。

\item 一个{\em 真实}的ISA，适用于直接的原生的硬件实现，而不仅仅是进行模拟或二进制翻译。

\item 一个对于特定微架构样式（例如，微编码的、有序的、解耦的、乱序的）
  或者实现技术（例如，全定制的、ASIC、FPGA）而言，避免了“过度的架构设计”（译者注：避免采用大而全的复杂微架构，超出了需求），
  但在这些的任何一个中都能高效实现的ISA。

\item 一个ISA被分成两个部分：1、一个{\em 小型}基础整数ISA，其可以用作定制加速器或教育目的的基础；
  2、可选的标准扩展，用于支持通用目的的软件环境。

\item 支持已修订的2008 IEEE-754浮点标准~\cite{ieee754-2008}。

\item 一个支持广泛ISA扩展和专用变体的ISA。

\item 32位和64位地址空间的变体都可以用于应用程序、操作系统内核、和硬件实现。

\item 一个支持高度并行的多核或众核实现（包括异构多处理器）的ISA。

\item 具有可选的{\em 可变长度指令}，可以扩展可用的指令编码空间，以及支持可选的{\em 稠密指令编码}，
以提升性能、静态编码尺寸和能效。

\item 一个完全虚拟化的ISA，以便简化监控器（Hypervisor）的开发。

\item 一个使新特权架构上的实验被简化的ISA。
\end{itemize}
\vspace{-0.1in}

\begin{commentary}
  我们设计决定的注释将采用像本段这样的格式。如果读者只对规范本身感兴趣，这种非正规的文本可以跳过。
\end{commentary}
\begin{commentary}
  选用RISC-V来命名，是为了表示UC伯克利设计的第五个主要的RISC ISA
  （前四个是RISC-I~\cite{riscI-isca1981}、RISC-II~\cite{Katevenis:1983}、SOAR~\cite{Ungar:1984}
  和SPUR~\cite{spur-jsscc1989}）。
  我们也用罗马字母“V”双关表示“变种（variations）”和“向量（vectors）”，
  因为，支持包括各种数据并行加速器在内的广泛的架构研究，是此ISA设计的一个明确的目标。
\end{commentary}


RISC-V ISA的设计，尽可能地避免了实现的细节（尽管注解包含了一些由实现所驱动的决策）；
它应当作为具有许多种实现的软件可见的接口来阅读，而不是作为某一特定硬件的定制品的设计来阅读。
RISC-V手册的结构分为两卷。
这一卷覆盖了基本的{\em 非特权(unprivileged)}指令的设计，
包括可选的非特权ISA扩展。
非特权指令是那些在所有权限架构的所有权限模式中，都能普遍可用的指令，
不过其行为可能随着权限模式和权限架构而变化。
第二卷提供了起初的（“经典的”）特权架构的设计。
手册使用IEC 80000-13:2008约定，每个字节有8位。


\begin{commentary}
  在非特权ISA的设计中，我们尝试去除任何依赖于特定微架构的特征，
  例如高速缓存的行（cache line）大小，或者特权架构的细节，
  例如页转换（page translation）。这既是为了简化，也是为选择各种可能的微架构，或各种可能的特权架构保持最大程度的灵活性。
\end{commentary}


\section{RISC-V硬件平台术语}

一个RISC-V硬件平台可以包含：一个或多个兼容RISC-V的处理核心（译者注：后续简称为RISC-V兼容核心或RISC-V核心）
与其它不兼容RISC-V的核心、固定功能的加速器、各种物理内存结构、I/O设备，和一个允许各组件通信的互联结构。

如果某个组件包含了一个独立的取指单元，那么它被称为一个{\em 核心}。
一个兼容RISC-V兼容的核心可以通过多线程，支持多个RISC-V兼容的{\em 硬件线程}（hardware thread，或称为hart）。

RISC-V核心可以有额外的专用指令集扩展，或者一个附加的{\em 协处理器（coprocessor）}。
我们使用术语“{\em 协处理器（coprocessor）}”来指代被接到RISC-V核心的单元。
其大部分时候顺序执行RISC-V指令流，但其还包含了额外的架构状态和指令集扩展，
并且可能保有与主RISC-V指令流相关的一些有限的自主权（译者注：这里指来自协处理器的、独立于主指令流的指令流）。

我们使用术语“{\em 加速器（accelerator）}”来指代一个不可编程的固定功能单元，
或者一个虽然能自主操作但是专用于特定任务的核心。
在RISC-V系统中，我们希望可编程加速器都基于RISC-V、带有专用指令集扩展和/或定制协处理器的核心。
RISC-V加速器的一个重要类别是I/O加速器，它为主应用核心分担了I/O处理任务的负载。

一个RISC-V硬件平台在系统级别的组织多种多样，范围可以从一个单核心微控制器到一个有数千节点
（其中每个节点又都是一个共享内存的众核服务器）的集群。
甚至小型片上系统都可能具有多层的多计算机和/或多处理器的结构，以使开发工作模块化，或者提供子系统间的安全隔离。

\section{RISC-V软件执行环境和硬件线程}

一个RISC-V程序的行为依赖于它所运行的执行环境。
RISC-V执行环境接口（execution environment interface，EEI）定义了：程序的初始状态、环境中的硬件线程
的数量和类型（包括被硬件线程支持的特权模式）、内存和I/O区域的可访问性和属性、
执行在各硬件线程上的所有合法指令的行为（例如，ISA就是EEI的一个组件），以及在包括环境调用在内的执行期间，任何中断或异常的处理。
EEI的例子包括了Linux应用程序二进制接口（ABI），或者RISC-V管理级（译者注：我们建议把supervisor翻译成监管器，后续的hypervisor翻译成超级监管器）二进制接口（SBI）。
一个RISC-V执行环境的实现可以是纯硬件的、纯软件的、或者是硬件和软件的组合。
例如，操作码陷入和软件模拟可以被用于实现硬件里没有提供的功能。执行环境的实际例子包括：


\begin{itemize}
  \item “裸机”（Bare metal）硬件平台：硬件线程直接通过物理处理器线程实现，
  指令对物理地址空间有完全访问权限。这个硬件平台定义了一个从加电复位开始的执行环境。

  \item RISC-V操作系统：通过将用户级硬件线程多路复用到可用的物理处理器线程上，
  以及通过虚拟内存来控制对内存的访问，提供了多个用户级别的执行环境。

  \item RISC-V 监管器（Hypervisor）：为宾客（guest）操作系统提供了多个监管器级别（supervisor-level）的执行环境。 

  \item RISC-V 模拟器（RISC-V emulator）：例如Spike、QEMU或rv8，它们在一个底层x86系统上模拟RISC-V硬件线程，
  并提供一个用户级别的或者监管器级别的执行环境。

\end{itemize}

\begin{commentary}
  可以考虑将一个裸的硬件平台定义为一个执行环境接口（EEI），
  它由可访问的硬件线程、内存、和其它设备来构成环境，且初始状态是加电复位时的状态。
  通常，大多数软件被设计为使用更抽象的接口，因为EEI越抽象，它所提供的跨不同硬件平台的可移植性越好。
  EEI经常是一层叠着一层的，一个较高层的EEI使用另一个较低层的EEI。
\end{commentary}

从软件在给定执行环境中运行的观点看，硬件线程是一种资源，它在执行环境中自动地获取和执行RISC-V指令。
在这个方面，硬件线程的行为像是一种硬件线程资源——即使被执行环境时分多路复用到了真实的硬件上。
一些EEI支持额外硬件线程的创建和销毁，例如，通过环境调用来派生新的硬件线程。

执行环境有义务确保它的各个硬件线程的最终向前推进（forward progress）。
当硬件线程在执行要明确等待某个事件的机制（例如本规范第二卷中定义的wait-for-interrupt指令）时，
该责任被挂起；当硬件线程终止时，该责任结束。硬件线程的向前推进是由下列事件构成的：

\vspace{-0.2in}
\begin{itemize}
\parskip 0pt
\itemsep 1pt
\item 一个指令的引退（retirement）。
\item 一个陷入，就像~\ref{sec:trap-defn}节中定义的那样。
\item 由组成向前推进的扩展所定义的任何其它事件。
\end{itemize}

\begin{commentary}

术语“硬件线程（hart）”的引入是在Lithe~\cite{lithe-pan-hotpar09,lithe-pan-pldi10}上的工作中，
是为了提供一个表示一种抽象的执行资源的术语，作为与软件线程编程抽象的对应。

硬件线程（hart）与软件线程上下文之间的重要区别是：
运行在执行环境中的软件不负责引发执行环境的各硬件线程的推进；那是外部执行环境的责任。
因此，从执行环境内部软件的观点看，环境的hart的操作就像硬件的线程一样。

一个执行环境的实现可能将一组宾客硬件线程（guest hart），时间多路复用到由它自己的
执行环境提供的更少的宿主硬件线程（host hart）上，
但是这种做法必须以一种“宾客硬件线程像独立的硬件线程那样操作”的方式进行。
特别地，如果宾客硬件线程比宿主硬件线程更多，那么执行环境必须有能力抢占宾客硬件线程，
而不是必须无限等待宾客硬件线程上的宾客软件来“让步（yield）”对宾客硬件线程的控制。

\end{commentary}

\section{RISC-V ISA 概览}

RISC-V ISA被定义为一个基础的整数ISA（在任何实现中都必须出现）和一些对基础ISA的可选的扩展。
基础整数ISA非常类似于早期的RISC处理器，除了没有分支延迟槽，但支持可选的变长指令编码。
“基础”是被小心地限制在足以为编译器、汇编器、链接器、和操作系统（带有额外特权操作）
提供合理目标的一个最小的指令集合的范围内，
提供了一个便捷的ISA和软件工具链“骨架”，可以围绕它们来构建更多定制的处理器ISA。

尽管使用“RISC-V ISA”这个词汇很方便，但其实RISC-V是一系列相关ISA的ISA族，族中目前有四个基础ISA。
每个基础整数指令集由不同的整数寄存器宽度、对应的地址空间尺寸和整数寄存器数目作为特征。
在第~\ref{rv32}章和第~\ref{rv64}章描述了两个主要的基础整数变体，RV32I和RV64I，
它们分别提供了32位和64位的地址空间。
我们使用术语“XLEN”来指代一个整数寄存器的位宽（32或者64位）。
第~\ref{rv32e}章描述了RV32I基础指令集的子集变体：RV32E，它已经被添加来支持小型微控制器，具有一半数目的整数寄存器。
第~\ref{rv128}章概述了基础整数指令集的一个未来变体RV128I，它将支持扁平的128位地址空间（XLEN＝128）。
基础整数指令集使用补码来表示有符号的整数值。

\begin{commentary}

尽管64位地址空间是更大的系统的需求，但我们相信在接下来的数十年里，32位地址空间仍然适合许多嵌入式和客户端设备，
并有望能够降低内存流量和能量消耗。此外，32位地址空间对于教育目的是足够的。
更大的扁平128位地址空间，也许最终会需要，因此我们要确保它能被容纳到RISC-V ISA框架之中。
\end{commentary}

\begin{commentary}

RISC-V中的四个基础ISA被作为不同的基础ISA对待。一个常见的问题是，为什么没有一个单一的ISA？
甚至特别地，为什么RV32I不是RV64I的一个严格的子集？
一些早期的ISA设计（SPARC、MIPS）为了支持已有的32位二进制在新的64位硬件上运行，
在增加地址空间大小的时候就采用了严格的超集策略。

明确地将基础ISA分离的主要优点在于，每个基础ISA可以按照自己的需求而优化，而不需要支持其他基础ISA需要的所有操作。
例如，RV64I可以忽略那些只有RV32I才需要的、处理较窄寄存器的指令和CSR。
RV32I变体则可以使用那些在更宽地址空间变体中需要留给指令的编码空间。

没有作为单一ISA设计的主要缺点是，它使在一个基础ISA上模拟另一个时所需的硬件复杂化（例如，在RV64I上模拟RV32I）。
然而，地址和非法指令陷入方面的不同总体上意味着，在任何时候（即使是完全的超集指令编码），硬件也将需要进行一些模式的切换；
而不同的RISC-V基础ISA是足够相似的，支持多个版本的成本相对较低。
虽然有些人已经提出，严格的超集设计将允许将遗留的32位库链接到64位代码，
但是由于软件调用约定和系统调用接口的不同，即使是兼容编码，这在实践中也是不实际的。

RISC-V权限架构提供了{\tt misa}中的域，用以在各级别控制非特权ISA，来支持在相同的硬件上模拟不同的基础ISA。
我们注意到，较新的SPARC和MIPS ISA修订版已经弃用不经改变就在64位系统上支持运行32位代码了。

一个相关的问题是，为什么32位加法对于RV32I（ADD）和RV64I（ADDW）有不同的编码？
ADDW操作码应当被用于RV32I中的32位加法，而ADDD应当被用于RV64I中的64位加法，而不是像现有设计这样，
将相同的操作码ADD用于RV32I中的32位加法和RV64I中的64位加法、
却将一个不同的操作码ADDW用于RV64I中的32位加法。
这也将与在RV32I和RV64I中对32位加载使用相同的LW操作码的做法保持一致性。
RISC-V ISA的最早版本的确有这种替代的设计，但是在2011年1月，RISC-V的设计变成了如今的选择。
我们的关注点在于在64位ISA中支持32位整数，而不在于提供对32位ISA的兼容性；
并且动机是消除RV32I中，并非所有操作码都有“*W”后缀所引起的不对称性（例如，有ADDW，但是AND没有ANDW）。
事后来看，同时设计两个ISA，而不是先设计一个再于其上追加设计另一个，作为如此做法的结果，这可能是不合适的；
而且，出于我们必须把平台的需求折进ISA规范之中的信条，那意味着在RV64I中将需要所有的RV32I的指令。
虽然现在改变编码已经太晚了，但是由于上述原因，这也几乎没有什么实际后果。

我们也能够将*W变体作为RV32I系统的一个扩展启用，以提供一种跨RV64I和未来RV32变体的常用编码
\end{commentary}

RISC-V已经被设计为支持广泛的定制和专用化。
每个基础整数ISA可以加入一个或多个可选的指令集进行扩展。一个扩展可以被归类为标准的、自定义的，或者不合规的。
出于这个目的，我们把每个RISC-V指令集编码空间（和相关的编码空间，例如CSR）划分为三个不相交的种类：
{\em 标准}、{\em 保留}、和{\em 自定义}。标准扩展和编码由RISC-V国际定义；
任何不由RISC-V国际定义的扩展都是{\em 非标准的}的。每个基础ISA及其标准扩展仅使用标准编码，并且在它们使用这些编码时不能相互冲突。
保留的编码当前还没有被定义，是省下来用于未来的标准扩展的；一旦如此使用，它们将变为标准编码。
自定义编码应当永远不被用于标准扩展，而是可用于特定供应商的非标准扩展。
非标准扩展或者是仅使用自定义编码的自定义扩展，或者是使用了任何标准或保留编码的{\em 非合规}的扩展。
指令集扩展一般是共享的，但是根据基础ISA的不同，也可能提供稍微不同的功能。
第~\ref{extensions}章描述了扩展RISC-V ISA的各种方法。我们也已经为基于RISC-V的指令和指令集开发了一套命名约定，
那将在第~\ref{naming}章进行详细的描述。


为了支持更一般的软件开发，RISC-V定义了一组标准扩展来提供整数乘法/除法、原子操作、和单精度与双精度浮点运算。
基础整数ISA被命名为“I”（根据整数寄存器的宽度配以“RV32”或“RV64”的前缀），
它包括了整数运算指令、整数加载、整数存储、和控制流指令。
标准整数乘法和除法扩展被命名为“M”，并添加了对整数寄存器中的值进行乘法和除法的指令。
标准原子指令扩展（用“A”表示）添加了对内存进行原子读、原子修改、和写内存的指令，用于处理器间的同步。
标准单精度浮点扩展（表示为“F”）添加了浮点寄存器、单精度运算指令，和单精度的加载和存储。
标准双精度浮点扩展（表示为“D”）扩展了浮点寄存器，并添加了双精度运算指令、加载、和存储。
标准“C”压缩指令扩展为通常的指令提供了较窄的16位形式。

在基础整数ISA和这些标准扩展之外，我们相信很少还会有新的指令对所有应用都将提供显著的益处，
尽管它也许对某个特定的领域很有帮助。随着对能效的关注迫使更加的专业化，
我们相信简化一个ISA规范中所必需的部分是很重要的。尽管其它架构通常把它们的ISA视为一个单独的实体，
这些ISA随着时间的推移、指令的添加，而变成一个新的版本；
RISC-V则将努力保持基础和各个标准扩展自始至终的恒定性，
新的指令改为作为未来可选的扩展分层。
例如，不管任何后续的扩展如何，基础整数ISA都将继续作为独立的ISA被完全支持。

\section{内存}

一个RISC-V硬件线程有共计$2^{\text{XLEN}}$字节的单字节可寻址空间，可用于所有的内存访问。
内存的一个“{\em 字（word）}”被定义为\wunits{32}{位}
(\wunits{4}{字节})。对应地，一个“{\em 半字（halfword）}”是\wunits{16}{位}
(\wunits{2}{字节})，一个“{\em 双字（doubleword）}”\wunits{64}{位}
(\wunits{8}{字节})，而一个“{\em 四字（quadword）}”是\wunits{128}{位}
(\wunits{16}{字节})。
内存地址空间是环形的，所以位于地址$2^{\text{XLEN}}-1$的字节与位于地址零的字节是相邻的。
因此，硬件进行内存地址计算时，忽略了溢出，代之以按模$2^{\text{XLEN}}$环绕。

执行环境决定了硬件资源到硬件线程地址空间的映射。
一个硬件线程的地址空间可以有不同地址范围，它可以是（1）空白的，或者（2）包含{\em 主内存}，
或者（3）包含一个或多个{\em I/O设备}。
I/O设备的直接读写会造成可见的副作用，但是访问主内存不会。
虽然执行环境有可能把硬件线程地址空间中的所有内容都称作I/O设备，但是通常都会把某些部分指定为主内存。

当一个RISC-V平台有多个硬件线程时，任意两个硬件线程的地址空间可以是完全相同的，或者完全不同的，
或者可以有部分不同但共享资源的一些子集，而这些资源被映射到相同或不同的地址范围。

\begin{commentary}

  对于一个纯粹的“裸机”环境，所有的硬件线程可以看到一个完全相同的地址空间，完全由物理地址进行访问。
  然而，当执行环境包含了带有地址转换的操作系统，通常会给每个硬件线程一个虚拟的地址空间，此空间很大程度上、或者完全就是线程自己的。
\end{commentary}

执行每个RISC-V机器指令涉及了一次或多次内存访问，这进一步可划分为{\em 隐式}和{\em 显式}访问。
对于每个被执行的指令，进行一次{\em 隐式}内存读（指令获取）是为了获得已编码指令进行执行。
许多RISC-V指令在指令获取之外不再进一步地访问内存。在由该指令决定的地址处，有专门的加载指令和存储指令对内存进行{\em 显式}的读或写。
执行环境可能要求指令执行除了非特权ISA所文档化的访问之外的其他{\em 隐式}内存访问（例如进行地址转换）。

执行环境决定了各种内存访问操作可以访问非空地址空间的哪些部分。
例如，可以被取指操作隐式读到的位置集合，可能与那些可以被加载（load）指令操作显式读到的位置集合有交叠；
以及，可以被存储（store）指令操作显式写到的位置集合，可能只是能被读到的位置集合的一个子集。
通常，如果一个指令尝试访问的内存位于一个不可访问的地址处，将因为该指令引发一个异常。
地址空间中的空白位置总是不可访问的。

除非特别说明，否则，不引发异常的隐式读可能会任意提前地、试探地发生，甚至是在机器能够证明的确需要读之前发生。
例如，一种合法实现方式是，可能会尝试第一时间读取所有的主内存，缓存尽可能多的可获取（可执行）字节以供之后的指令获取，
以及避免为了指令获取而再次读主内存（译者注：即通常所说的指令预取）
为了确保某些隐式读只在写入相同内存位置之后是有序的，软件必须执行为此目的而定义的、特定的屏障指令或缓存控制指令
（例如第~\ref{chap:zifencei}章里定义的FENCE.I指令）。

由一个硬件线程发起的内存访问（隐式或显式），在被另一个硬件线程、或者任何其它可访问相同内存的代理线程所感知时，
可能看起来像是以一种不同的顺序发生的。然而，这个被感知到的内存访问重新排序总是受到特定的内存一致性模型的约束。
用于RISC-V的默认的内存一致性模型是RISC-V弱内存排序（RVWMO），定义在第~\ref{ch:memorymodel}章和附录中。
也可以采用更强的模型：全存储排序（Total Store Ordering），定义在第~\ref{sec:ztso}章中。
执行环境也可以添加约束，进一步限制的可感知的内存访问的重排。
由于RVWMO模型是被任何RISC-V实现所允许的最弱的模型，用这个模型写出的软件兼容所有RISC-V实现的实际的内存一致性规则。
与隐式读一样，除非假定的内存一致性模型和执行环境有其他特别需求，否则软件必须执行屏障或缓存控制指令来确保特定顺序的内存访问。

\section{基础指令长度编码}

基础RISC-V ISA有固定长度的32位指令，必须在32位边界上自然地对齐。
然而，标准RISC-V编码策略被设计为支持具有可变长度指令的ISA扩展指令，
每条指令在长度上可以是任意数目的16位指令的{\em 封装包（parcel）}，指令封装包在16位边界自然对齐。
第~\ref{compressed}章中描述的标准压缩ISA扩展（译者注：即C扩展）减少了代码尺寸，通过提供压缩的16位指令，以及放松了对齐的限制，
允许所有的指令（16位和32位）在任意16位边界上对齐，而提升了代码的密度。

我们使用术语“IALIGN”（以位为单位）来表示实现层面所采用的指令空间对齐约束。在基础ISA中，IALIGN是32位。
但是在某些ISA扩展中，包括在压缩ISA扩展中，将IALIG是宽松的16位。IALIGN不能取除了16和32以外的任何其它值。

我们使用术语“ILEN”（以位为单位）来表示实现层面所支持的最大指令长度，它总是IALIGN的倍数。
对于只支持一个基础指令集的实现，ILEN是32位。支持更长指令的具体实现架构也就有更大的ILEN值。

图~\ref{instlengthcode}描绘了标准RISC-V指令长度编码约定。
基础ISA中的所有的32位指令都把它们的最低二位设置为“{\tt 11}”。
而可选的压缩16位指令集扩展，它们的最低二位等于“{\tt 00}”、“{\tt 01}”、或“{\tt 10}”。

\subsection*{拓展的指令长度编码}

32位指令编码空间的一部分已经被初步分配给了长度超过32位的指令。
目前这片空间的整体是被保留的，而且下面的关于超过32位编码的提议并没有被认为已被冻结。

带有超过32位编码的标准指令集扩展将额外的若干低序位设置为1（即图~\ref{instlengthcode}中的bbb=111，
关于48位和64位长度的约定如图~\ref{instlengthcode}所示。
指令长度在80位到176位之间的，使用[14:12]中3位（即图~\ref{instlengthcode}中的nnn）来编码，
并给出除最先的5$\times$16位字（80位字）以外的16位的字的数目（即图~\ref{instlengthcode}中的nnn的实际值）。
位[14:12]被设置为“{\tt 111}”的编码被保留，用于未来更长的指令编码。


\begin{figure}[hbt]
{
\begin{center}
\begin{tabular}{ccccl}
\cline{4-4}
& & & \multicolumn{1}{|c|}{\tt xxxxxxxxxxxxxxaa} & 16位 ({\tt aa}
$\neq$ {\tt 11})\\
\cline{4-4}
\\
\cline{3-4}
& & \multicolumn{1}{|c|}{\tt xxxxxxxxxxxxxxxx}
& \multicolumn{1}{c|}{\tt xxxxxxxxxxxbbb11} & 32位 ({\tt bbb}
$\neq$ {\tt 111}) \\
\cline{3-4}
\\
\cline{2-4}
\hspace{0.1in} 
& \multicolumn{1}{c|}{$\cdot\cdot\cdot${\tt xxxx} }
& \multicolumn{1}{c|}{\tt xxxxxxxxxxxxxxxx}
& \multicolumn{1}{c|}{\tt xxxxxxxxxx011111} & 48位 \\
\cline{2-4}
\\
\cline{2-4}
\hspace{0.1in} 
& \multicolumn{1}{c|}{$\cdot\cdot\cdot${\tt xxxx} }
& \multicolumn{1}{c|}{\tt xxxxxxxxxxxxxxxx}
& \multicolumn{1}{c|}{\tt xxxxxxxxx0111111} & 64位 \\
\cline{2-4}
\\
\cline{2-4}
\hspace{0.1in} 
& \multicolumn{1}{c|}{$\cdot\cdot\cdot${\tt xxxx} }
& \multicolumn{1}{c|}{\tt xxxxxxxxxxxxxxxx}
& \multicolumn{1}{c|}{\tt xnnnxxxxx1111111} & (80+16*{\tt nnn})位,
       {\tt nnn}$\neq${\tt 111} \\
\cline{2-4}
\\
\cline{2-4}
\hspace{0.1in} 
& \multicolumn{1}{c|}{$\cdot\cdot\cdot${\tt xxxx} }
& \multicolumn{1}{c|}{\tt xxxxxxxxxxxxxxxx}
& \multicolumn{1}{c|}{\tt x111xxxxx1111111} & 保留用于 $\geq$192位 \\
\cline{2-4}
\\
字节地址: & \multicolumn{1}{r}{base+4} & \multicolumn{1}{r}{base+2} & \multicolumn{1}{r}{base} & \\
 \end{tabular}
\end{center}
}
\caption{RISC-V 指令长度编码。 当前只有16位和32位编码已被冻结。}
\label{instlengthcode}
\end{figure}

\begin{commentary}

  考虑到压缩格式的代码尺寸和节能效果，我们希望在ISA编码策略中构建对压缩格式的支持，
  而不是事后才想起添加它；但是为了允许更简单的实现，我们不想强制规定压缩格式。
  我们也希望允许更长的指令，以支持一些实验和更大的指令集扩展。
  尽管我们这种编码约定要求更严格的核心RISC-V ISA编码，但是这样做收益良多。

  一个标准IMAFD ISA的实现只需要在指令缓存中持有最主要的30位（节省了6.25\%）。在
  指令缓存重新填充时，任何遇到有低位被清除的指令，应当在存进缓存之前，重新编码为非法的30位指令，以保持非法指令异常的行为。

  也许更重要的是，通过把我们的基础ISA凝炼成32位指令字的子集，
  我们为非标准的和自定义的指令集扩展留出了更多可用的空间。
  特别地，基础RV32I ISA在32位指令字中使用少于1/8的编码空间。
  正如第\ref{extensions}章中描述的那样，一个不需要支持标准压缩指令扩展的实现，
  可以将3个额外的不一致的30位指令空间映射到32位固定宽度格式，同时保留对$\geq$32位标准指令集扩展的支持。
  甚至，如果实现层面也不需要长度$>$32位的指令，它可以把这些不一致扩展恢复成另外四种主要的操作码。
\end{commentary}

位[15:0]都是0的编码被定义为非法指令。如果存在任何16位指令集扩展，
则这些指令被认为具有最小的长度：16位，否则是32位。位[ILEN-1:0]都是1的编码也是非法的；这个指令的长度被认为是ILEN位。

\begin{commentary}

我们认为有一个特征是，所有位都是“0”的任意长度的指令都是不合法的，
因为这很快会让陷入处理错误地跳转到零内存区域。类似地，我们也保留了包含所有“1”的指令编码作为非法指令，
以捕获在无编程的非易失性内存设备、断连的内存总线、或者断开的内存设备上通常观测到的出错模式。

在所有的RISC-V实现上，软件可以依靠将一个包含“0”的自然对齐的32位字作为一个非法指令，
以供明确需要非法指令的软件使用。由于可变长度编码，定义一个相应的全是“1”的已知非法值是更加困难的。
软件不能一般地使用ILEN位全是“1”的非法值，因为软件可能不知道最终的目标机器的ILEN
（例如，如果软件被编译为一个用于许多不同机器的标准二进制库）。我们也考虑了定义一个全是“1”的32位字作为非法指令，
因为所有的机器必须支持32位指令尺寸，但是这需要在ILEN$>$32的机器上的指令获取单元报告一个非法指令异常，
而不是在这种指令接近保护边界时报告一个访问故障异常，让可变指令长度的取指和解码变得复杂。

\end{commentary}

RISC-V基础ISA既有小字节序的内存系统，也有大字节序的内存系统，后者需要特权架构进一步定义大字节序的操作。
不论内存系统的字节序如何，指令都作为16位小字节序的封装包的序列被存储在内存中
。构成一个指令的封装包被存储在地址递增的半字地址处，封装包的最低地址持有指令规范中指令的最低若干位。

\begin{commentary}

我们最初为RISC-V内存系统选择小字节序的字节次序，因为小字节序系统当前在商业上占主导
（所有的x86系统；iOS、安卓，和用于ARM的Windows）。
一个小问题是，我们已经发现，小字节序内存系统对于硬件设计者更加自然。
但是，考虑到特定的应用领域（例如IP网络）在大字节序数据结构上的操作，
以及基于大字节序处理器构建的特定遗留代码，所以我们也已经定义了RISC-V的大字节序和双字节序变体。

我们不得不固定指令封装包在内存中存储的顺序，而且不依赖于内存系统的字节序，
来确保长度编码位始终以半字地址顺序首先出现。这允许取指单元通过只检查第一个16位指令包的最初几位，就快速决定可变长度指令的长度。

我们更进一步地把指令封装包本身做成小字节序的，以便从内存系统字节序中把指令编码完全解耦出来。
这个设计对软件工具和双字节序硬件都有好处。否则，例如一个RISC-V汇编器或反汇编器将总是需要预先知道当前运行系统的字节序，
尽管在双字节序系统中，字节序的模式可能在执行期间动态变化。
与之相反，通过给定指令一个固定的字节序，有时可以让编写软件无需感知字节序，甚至是以二进制形式的软件，就像位置无关代码（PIC）一样。

然而，对于编码或解码机器指令的RISC-V软件来说，选择只有小字节序的指令的确会有后果。
例如，大字节序的JIT编译器在向指令内存处执行存储操作的时候，必须交换字节的次序。

一旦我们已经决定了固定为小字节序指令编码，这将自然地导致把长度编码位放置在指令格式的LSB\footnote{译者注：Least Significant Bit，最低有效位}的位置，以避免打断操作码域。
\end{commentary}

\section{异常、陷入和中断}
\label{sec:trap-defn}

我们使用术语“{\em 异常（Exception）}”来指代一种发生在运行时的不正常的状况，
它与当前RISC-V硬件线程中的一条指令相关联。我们使用术语“{\em 中断（Interrupt）}”来指代一种外部的异步事件，
它可能导致一个RISC-V硬件线程经历一次意料之外的控制转移。
我们使用术语“{\em 陷入（Trap）}”来指代由一个异常或中断引发的将控制权转移到陷入处理程序的过程。

下面的章节中的指令描述了在指令执行期间可以引发异常的条件。
大多数RISC-V EEI的通常行为是，当在一个指令上发出异常的信号时，会发生一次到某些处理程序的陷入
（标准浮点扩展中的浮点异常除外，那些并不引起陷入）。硬件线程产生中断、中断路由、和中断启用的具体方式依赖于EEI。


\begin{commentary}
  
  我们使用的“异常”和“陷入”概念与IEEE-754浮点标准中的相兼容。
\end{commentary}

陷入是如何处理的，以及对运行在硬件线程上的软件的可见性如何，依赖于外围的执行环境。
从运行在执行环境内部的软件的视角，在运行时遭遇硬件线程的陷入将有四种不同的影响：
\begin{description}
  \item[被控制的陷入：] 这种陷入对于运行在执行环境中的软件可见，并由软件处理。
  例如，在一个于硬件线程上同时提供监管器模式和用户模式的EEI中，
  用户模式硬件线程的ECALL通常将导致控制被转移到运行在相同硬件线程上的一个监管器模式的处理程序。
  类似地，在相同的环境中，当一个硬件线程被中断，硬件线程上将运行一个监管器模式中的中断处理程序。
  \item[被请求的陷入：] 这种陷入是一个同步的异常，它是对执行环境的一种显式调用，
  请求了一个代表执行环境内部的软件的动作。一个例子便是系统调用。
  在这种情况下，执行环境采取了被请求的动作后，硬件线程上的执行可能继续，也可能不会继续。
  例如，一个系统调用可以移除硬件线程，或者引起整个执行环境的有序终止。
  \item[不可见的陷入：] 这种陷入被执行环境透明地处理了，并且在陷入被处理之后，执行正常继续。
  例子包括模拟缺失的指令、在按需分页的虚拟内存系统中处理非常驻页故障，或者在多程序机器中为不同的事务处理设备中断。
  在这些情况中，运行在执行环境中的软件不会意识到陷入（我们忽略了这些定义中的时间影响）。
  \item[致命的陷入：] 这种陷入代表了一个致命的失败，并引发执行环境终止执行。
  例子包括虚拟内存页保护检查的失败，或者看门狗\footnote{译者注：watchdog，一种用于访问保护的装置}计时器到期。
  每个EEI应当定义执行应如何被终止，以及如何将其汇报给外部环境。
\end{description}

表~\ref{table:trapcharacteristics} 显示了每种陷入的特点：

\begin{table}[hbt]
  \centering
  \begin{tabular}{|l|c|c|c|c|}
      \hline
                & 被控制的 & 被请求的 & 不可见的 & 致命的\\
      \hline
      执行终止   & 否     & 否$_{1}$ & 否  & 是 \\
      软件被遗忘 & 否     & 否       & 是 & 是$_{2}$ \\
      由环境处理 & 否     & 是       & 是 & 是 \\
      \hline
  \end{tabular}
  \caption{陷入的特点。 注：1） 可以被请求终止. 2） 不精确的致命的陷入或许可被软件观测到。}
\label{table:trapcharacteristics}
\end{table}

EEI为每个陷入定义了它是否会被精确处理，尽管通常建议是尽可能地保持精确处理。
被控制的陷入和被请求的陷入可以被执行环境内部的软件观测到是不精确的。
不可见的陷入，根据定义，不能被运行在执行环境内部的软件观测到是否精确。
致命陷入可以被运行在执行环境内部的软件观测到不精确，如果已知错误的指令没有引起直接的终止的话。

因为这篇文档描述了非特权指令，所以陷入是很少被提及的。
处理包含陷入的架构性方法被定义在特权架构手册中，伴有支持更丰富EEI的其它特征。
这里只记录了被单独定义的引发请求陷入的非特权指令。
根据不可见的陷入的性质，其超出了这篇文档的讨论范围。
没有在本文档中定义的指令编码，和没有被一些其它方式定义的指令编码，可以引起致命陷入。

\section{“未指定的”（UNSPECIFIED）行为和值}

架构完全描述了架构必须做的事和任何关于它们可能做的事的约束。
对于那些架构有意不约束实现的情况，会显式地使用术语“\unspecified”。

术语“\unspecified”指代了一种有意不进行约束的行为或值。
这些行为或值对于扩展、平台标准或实现是开放的。
对于基础架构定义为“\unspecified”的情形，扩展、平台标准或实现文档可以提供规范性内容以进一步约束。

像基础架构一样，扩展架构应当完全描述清楚所允许的行为和值，并使用术语“\unspecified”用于有意不做约束的情况。
对于这种情况，就可以被其它的扩展、平台标准或实现来约束或定义。
