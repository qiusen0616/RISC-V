% Package includes

\usepackage{graphicx}
\usepackage{geometry}
\usepackage{array}
\usepackage{colortbl}
\usepackage[svgnames]{xcolor}

\usepackage[colorlinks,citecolor=Navy,linkcolor=Navy]{hyperref}
\usepackage{placeins}
\usepackage{longtable}
\usepackage{multirow}
\usepackage{float}
\usepackage{listings}
\usepackage{comment}
\usepackage{enumitem}
\usepackage{verbatimbox}
\usepackage{amsmath}

\usepackage[olditem,oldenum]{paralist}
\usepackage[UTF8,heading = true]{ctex}
\usepackage{indentfirst}
\usepackage{pfnote}

% Setup margins

\setlength{\topmargin}{-0.5in}
\setlength{\textheight}{9in}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}

% Useful macros

\newcommand{\note}[1]{{\bf [ NOTE: #1 ]}}
\newcommand{\fixme}[1]{{\bf [ FIXME: #1 ]}}
\newcommand{\todo}[1]{\marginpar{\footnotesize #1}}

\newcommand{\wunits}[2]{\mbox{#1\,#2}}
\newcommand{\um}{\mbox{$\mu$m}}
\newcommand{\xum}[1]{\wunits{#1}{\um}}
\newcommand{\by}[2]{\mbox{#1$\times$#2}}
\newcommand{\byby}[3]{\mbox{#1$\times$#2$\times$#3}}

\newlength\savedwidth
\newcommand\whline[1]{%
  \noalign{%
    \global\savedwidth\arrayrulewidth\global\arrayrulewidth 1.5pt%
  }%
  \cline{#1}%
  \noalign{\vskip\arrayrulewidth}%
  \noalign{\global\arrayrulewidth\savedwidth}%
}

% Custom ctex: chapter and section

\ctexset{
chapter/name = {第,章},
chapter/format = { \huge\bfseries },
section/format = { \Large\bfseries },
}

% Custom list environments

\newlist{tightlist}{itemize}{1}
\setlist[tightlist]{label=\textbullet,nosep}

\newenvironment{titledtightlist}[1]
{\noindent
 ~~\textbf{#1}
 \begin{tightlist}}
{\end{tightlist}}

\newenvironment{commentary}
{	\vspace{-1.5mm}
	\list{}{
		\topsep		0mm
		\partopsep	0mm
		\listparindent	1.5em
		\itemindent	\listparindent
		\rightmargin	\leftmargin
		\parsep		0mm
	}
	\item
	\small\em
	\noindent\nopagebreak\rule{\linewidth}{1pt}\par
	\noindent\ignorespaces
}
{\endlist}

%\newenvironment{discussion}
%{	\vspace{-1.5mm}
%	\list{}{
%		\topsep		0mm
%		\partopsep	0mm
%		\listparindent	1.5em
%		\itemindent	\listparindent
%		\rightmargin	\leftmargin
%		\parsep		0mm
%	}
%	\item
%	\small\em
%	\noindent\nopagebreak\rule{\linewidth}{1pt}\par
%	\noindent\textbf{Discussion:}
%}
%{\endlist}

% Other commands and parameters

\pagestyle{myheadings}
\setlength{\parindent}{0in}
\setlength{\parskip}{10pt}
\sloppy
\raggedbottom
\clubpenalty=10000
\widowpenalty=10000

% Commands for register format figures.

% New column types to use in tabular environment for instruction formats.
% Allocate 0.18in per bit.
\newcolumntype{I}{>{\centering\arraybackslash}p{0.18in}}
% Two-bit centered column.
\newcolumntype{W}{>{\centering\arraybackslash}p{0.36in}}
% Three-bit centered column.
\newcolumntype{F}{>{\centering\arraybackslash}p{0.54in}}
% Four-bit centered column.
\newcolumntype{Y}{>{\centering\arraybackslash}p{0.72in}}
% Five-bit centered column.
\newcolumntype{R}{>{\centering\arraybackslash}p{0.9in}}
% Six-bit centered column.
\newcolumntype{S}{>{\centering\arraybackslash}p{1.08in}}
% Seven-bit centered column.
\newcolumntype{O}{>{\centering\arraybackslash}p{1.26in}}
% Eight-bit centered column.
\newcolumntype{E}{>{\centering\arraybackslash}p{1.44in}}
% Ten-bit centered column.
\newcolumntype{T}{>{\centering\arraybackslash}p{1.8in}}
% Twelve-bit centered column.
\newcolumntype{M}{>{\centering\arraybackslash}p{2.2in}}
% Sixteen-bit centered column.
\newcolumntype{K}{>{\centering\arraybackslash}p{2.88in}}
% Twenty-bit centered column.
\newcolumntype{U}{>{\centering\arraybackslash}p{3.6in}}
% Twenty-bit centered column.
\newcolumntype{L}{>{\centering\arraybackslash}p{3.6in}}
% Twenty-five-bit centered column.
\newcolumntype{J}{>{\centering\arraybackslash}p{4.5in}}

\newcommand{\instbit}[1]{\mbox{\scriptsize #1}}
\newcommand{\instbitrange}[2]{~\instbit{#1} \hfill \instbit{#2}~}
\newcommand{\reglabel}[1]{\hfill {\tt #1}\hfill\ }

\newcommand{\wiri}{\textbf{WIRI}}
\newcommand{\wpri}{\textbf{WPRI}}
\newcommand{\wlrl}{\textbf{WLRL}}
\newcommand{\warl}{\textbf{WARL}}

\newcommand{\unspecified}{\textsc{未指定的}}


\newcommand{\ppost}{$b$是一个存储操作，且$a$和$b$访问了重叠的内存地址
  % $b$ is a store, and $a$ and $b$ access overlapping memory addresses
}
\newcommand{\ppofence}{在$b$之前有一个排序$a$的FENCE指令 
% There is a FENCE instruction that orders $a$ before $b$
}
\newcommand{\ppoacquire}{$a$有一个acquire注释
  % $a$ has an acquire annotation
  }
\newcommand{\pporelease}{$b$有一个release注释
  % $b$ has a release annotation
  }
\newcommand{\pporcsc}{$a$和$b$都有RCsc注释
  % $a$ and $b$ both have RCsc annotations
  }
\newcommand{\ppoamoforward}{$a$是由AMO或SC指令生成的操作，$b$是加载操作，且$b$返回一个由$a$写入的值
  % $a$ is generated by an AMO or SC instruction, $b$ is a load, and $b$ returns a value written by $a$
  }
\newcommand{\ppoaddr}{b有一个关于a的句法地址依赖
  % $b$ has a syntactic address dependency on $a$
  }
\newcommand{\ppodata}{$b$有一个关于$a$的句法数据依赖
  % $b$ has a syntactic data dependency on $a$
  }
\newcommand{\ppoctrl}{$b$是一个存储操作，且$b$有一个关于$a$的句法控制依赖
  % $b$ is a store, and $b$ has a syntactic control dependency on $a$
  }
\newcommand{\ppopair}{$a$与$b$是成对的
  % $a$ is paired with $b$
  }
\newcommand{\ppordw}{$a$和$b$是加载操作，$x$是$a$和$b$都读取的一个字节，以程序次序在$a$和$b$之间没有对$x$的存储操作，并且$a$和$b$返回由不同的内存操作所写入的$x$的值
  % $a$ and $b$ are loads, $x$ is a byte read by both $a$ and $b$, there is no store to $x$ between $a$ and $b$ in program order, and $a$ and $b$ return values for $x$ written by different memory operations
  }
\newcommand{\ppoaddrdatarfi}{
  $b$是一个加载操作，且按程序次序，在$a$和$b$之间存在某些存储操作$m$，使得$m$有一个关于$a$的地址依赖或数据依赖，而$b$返回一个由$m$写入的值
  % $b$ is a load, and there exists some store $m$ between $a$ and $b$ in program order such that $m$ has an address or data dependency on $a$, and $b$ returns a value written by $m$
  }
\newcommand{\ppoaddrpo}{$b$是一个存储操作，且按程序次序，在$a$和$b$之间存在某些指令$m$，使$m$有一个关于$a$的地址依赖
  % $b$ is a store, and there exists some instruction $m$ between $a$ and $b$ in program order such that $m$ has an address dependency on $a$
  }
\newcommand{\loadvalueaxiom}{
  每个加载$i$的各个位所返回的值，由下列存储中在全局内存次序中最近的那个写到该位：
  % Each byte of each load $i$ returns the value written to that byte by the store that is the latest in global memory order among the following stores:
  \begin{enumerate}
    \item 写该位，并且在全局内存次序中先于$i$的存储  % Stores that write that byte and that precede $i$ in the global memory order
    \item 写该位，并且在程序次序中先于$i$的存储  % Stores that write that byte and that precede $i$ in program order
  \end{enumerate}
}

\newcommand{\atomicityaxiom}{
  如果$r$和$w$是由一个硬件线程$h$中对齐的LR和SC指令所生成的配对的加载和存储操作，
  $s$是一个对于字节$x$的存储，而$r$返回$s$所写的值，那么在全局内存次序中，$s$必须先于$w$。
  并且在全局内存次序中，在$s$之后、$w$之前，没有来自同一硬件线程的不同于$h$的存储。
  % If $r$ and $w$ are paired load and store operations generated by aligned LR and SC instructions in a hart $h$, 
  % $s$ is a store to byte $x$, and $r$ returns a value written by $s$, then $s$ must precede $w$ in the global memory order, 
  % and there can be no store from a hart other than $h$ to byte $x$ following $s$ and preceding $w$ in the global memory order.
}

\newcommand{\progressaxiom}{
  在全局内存次序之中，任何内存操作之前都不能有其它内存操作的无限序列。
  % No memory operation may be preceded in the global memory order by an infinite sequence of other memory operations.
  }
